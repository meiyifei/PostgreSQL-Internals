# 		查询分析与重写模块源代码学习

## 一、语法分析和解析模块

### 模块作用

​	用户输入的SQL STATEMENT，经过解析器(Parser),会生成一颗语法树(parser tree)。

### 模块具体实现

​	已经知道SQL语句经过该模块会生成一颗语法树，那么这个流程是怎样实现的呢？

为了能够正确的识别用户输入的SQL语句，PostgreSQL使用词法分析器和语法分析器，按照一定的规则处理来自用户输入的SQL语句。

词法分析器按照词法规则(src/backend/parser/scan.l)，识别SQL语句中单词。

语法分析器按照语法规则(src/backend/parser/gram.y)，对已经转换为单词的SQL语句进行处理，形成SelectStmt节点(语法树的根节点)。

#### SelectStmt数据结构

```c
/*
	src/include/nodes/parsenodes.h
*/
typedef struct SelectStmt
{
	NodeTag		type;

	/*
	 * These fields are used only in "leaf" SelectStmts.
	 */
	List	   *distinctClause; /* NULL, list of DISTINCT ON exprs, or
								 * lcons(NIL,NIL) for all (SELECT DISTINCT) */
	IntoClause *intoClause;		/* target for SELECT INTO */
	List	   *targetList;		/* the target list (of ResTarget) */
	List	   *fromClause;		/* the FROM clause */
	Node	   *whereClause;	/* WHERE qualification */
	List	   *groupClause;	/* GROUP BY clauses */
	Node	   *havingClause;	/* HAVING conditional-expression */
	List	   *windowClause;	/* WINDOW window_name AS (...), ... */

	/*
	 * In a "leaf" node representing a VALUES list, the above fields are all
	 * null, and instead this field is set.  Note that the elements of the
	 * sublists are just expressions, without ResTarget decoration. Also note
	 * that a list element can be DEFAULT (represented as a SetToDefault
	 * node), regardless of the context of the VALUES list. It's up to parse
	 * analysis to reject that where not valid.
	 */
	List	   *valuesLists;	/* untransformed list of expression lists */

	/*
	 * These fields are used in both "leaf" SelectStmts and upper-level
	 * SelectStmts.
	 */
	List	   *sortClause;		/* sort clause (a list of SortBy's) */
	Node	   *limitOffset;	/* # of result tuples to skip */
	Node	   *limitCount;		/* # of result tuples to return */
	List	   *lockingClause;	/* FOR UPDATE (list of LockingClause's) */
	WithClause *withClause;		/* WITH clause */

	/*
	 * These fields are used only in upper-level SelectStmts.
	 */
	SetOperation op;			/* type of set op */
	bool		all;			/* ALL specified? */
	struct SelectStmt *larg;	/* left child */
	struct SelectStmt *rarg;	/* right child */
	/* Eventually add fields for CORRESPONDING spec here */
} SelectStmt;
```

SelectStmt规则定义

```c
/*
	IDENTIFICATION
	src/backend/parser/gram.y
*/
//select语句的类型
SelectStmt: select_no_parens			%prec UMINUS
			| select_with_parens		%prec UMINUS
		;

select_with_parens:
			'(' select_no_parens ')'				{ $$ = $2; }
			| '(' select_with_parens ')'			{ $$ = $2; }
		;

/*
 * This rule parses the equivalent of the standard's <query expression>.
 * The duplicative productions are annoying, but hard to get rid of without
 * creating shift/reduce conflicts.
 *
 *	The locking clause (FOR UPDATE etc) may be before or after LIMIT/OFFSET.
 *	In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
 *	We now support both orderings, but prefer LIMIT/OFFSET before the locking
 * clause.
 *	2002-08-28 bjm
 */
//根据语法规则匹配是简单的select类型，还是带有其他子句的select
//也就是简单select+可选的子句
select_no_parens:
			simple_select						{ $$ = $1; }
			| select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $1, $2, NIL,
										NULL, NULL, NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause for_locking_clause opt_select_limit
				{
					insertSelectOptions((SelectStmt *) $1, $2, $3,
										list_nth($4, 0), list_nth($4, 1),
										NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
					insertSelectOptions((SelectStmt *) $1, $2, $4,
										list_nth($3, 0), list_nth($3, 1),
										NULL,
										yyscanner);
					$$ = $1;
				}
			| with_clause select_clause
				{
					insertSelectOptions((SelectStmt *) $2, NULL, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $2, $3, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit
				{
					insertSelectOptions((SelectStmt *) $2, $3, $4,
										list_nth($5, 0), list_nth($5, 1),
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
					insertSelectOptions((SelectStmt *) $2, $3, $5,
										list_nth($4, 0), list_nth($4, 1),
										$1,
										yyscanner);
					$$ = $2;
				}
		;
		select_clause:
			simple_select							{ $$ = $1; }
			| select_with_parens					{ $$ = $1; }
		;

//simple_select可以包括问题的本质，具体看看简单查询具体的语法规则
//可以看到更据select子句的不同搭配有不同的语法匹配规则，但是都形成了SelectStmt节点
simple_select:
			SELECT opt_all_clause opt_target_list
			into_clause from_clause where_clause
			group_clause having_clause window_clause
				{
				//形成SelectStmt节点
					SelectStmt *n = makeNode(SelectStmt);
/*
					不难发现 opt_target_list子句的匹配规则其实就是形成targetList节点,作为SelectStmt根节点的一个分支节点，类似的其他节点也作为分支节点经过语法解析后加到根节点上。
					target list for SELECT
 *****************************************************************************
opt_target_list: target_list						{ $$ = $1; }
			| /* EMPTY */							{ $$ = NIL; }
			;

target_list:
			target_el								{ $$ = list_make1($1); }
			| target_list ',' target_el				{ $$ = lappend($1, $3); }
		;

target_el:	a_expr AS ColLabel
				{
					$$ = makeNode(ResTarget);
					$$->name = $3;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
					
*/
					n->targetList = $3;
					n->intoClause = $4;
					n->fromClause = $5;
					n->whereClause = $6;
					n->groupClause = $7;
					n->havingClause = $8;
					n->windowClause = $9;
					$$ = (Node *)n;
				}
			| SELECT distinct_clause target_list
			into_clause from_clause where_clause
			group_clause having_clause window_clause
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->distinctClause = $2;
					n->targetList = $3;
					n->intoClause = $4;
					n->fromClause = $5;
					n->whereClause = $6;
					n->groupClause = $7;
					n->havingClause = $8;
					n->windowClause = $9;
					$$ = (Node *)n;
				}
			| values_clause							{ $$ = $1; }
			| TABLE relation_expr
				{
					/* same as SELECT * FROM relation_expr */
					ColumnRef *cr = makeNode(ColumnRef);
					ResTarget *rt = makeNode(ResTarget);
					SelectStmt *n = makeNode(SelectStmt);

					cr->fields = list_make1(makeNode(A_Star));
					cr->location = -1;

					rt->name = NULL;
					rt->indirection = NIL;
					rt->val = (Node *)cr;
					rt->location = -1;

					n->targetList = list_make1(rt);
					n->fromClause = list_make1($2);
					$$ = (Node *)n;
				}
			| select_clause UNION all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_UNION, $3, $1, $4);
				}
			| select_clause INTERSECT all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_INTERSECT, $3, $1, $4);
				}
			| select_clause EXCEPT all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_EXCEPT, $3, $1, $4);
				}
		;
```

以上完成了SQL语句到语法树的转换，但是在转换过程中仅仅是对SQL语句进行词法和语法分析(只要SQL符合语法就不会报错)，并没有对SQL语句中语法对象的有效性进行验证并且如果targetlist为‘*’的话，需要转换为基表的列名，而这些工作由分析器来完成。

## 二、查询分析模块

### 模块作用

​	对语法树进行分析(语法对象的有效性验证和*号的转换等工作)

### 模块具体实现

​	输入的parse tree(根节点SelectStmt节点)，输出的query tree(根节点Query)。下面给出在生成查询树过程中用到的一些重要的数据结构。

#### Query数据结构

```c
/*
	src/include/nodes/parsenodes.h
*/
typedef struct Query
{
	NodeTag		type;

	CmdType		commandType;	/* select|insert|update|delete|utility */

	QuerySource querySource;	/* where did I come from? */

	uint64		queryId;		/* query identifier (can be set by plugins) */

	bool		canSetTag;		/* do I set the command result tag? */

	Node	   *utilityStmt;	/* non-null if commandType == CMD_UTILITY */

	int			resultRelation; /* rtable index of target relation for
								 * INSERT/UPDATE/DELETE; 0 for SELECT */

	bool		hasAggs;		/* has aggregates in tlist or havingQual */
	bool		hasWindowFuncs; /* has window functions in tlist */
	bool		hasTargetSRFs;	/* has set-returning functions in tlist */
	bool		hasSubLinks;	/* has subquery SubLink */
	bool		hasDistinctOn;	/* distinctClause is from DISTINCT ON */
	bool		hasRecursive;	/* WITH RECURSIVE was specified */
	bool		hasModifyingCTE;	/* has INSERT/UPDATE/DELETE in WITH */
	bool		hasForUpdate;	/* FOR [KEY] UPDATE/SHARE was specified */
	bool		hasRowSecurity; /* rewriter has applied some RLS policy */

	List	   *cteList;		/* WITH list (of CommonTableExpr's) */

	List	   *rtable;			/* list of range table entries */
    
    /*
     typedef struct FromExpr
 	{
    	 NodeTag     type;
    	 List       *fromlist;       /* List of join subtrees */
    	 Node       *quals;          /* qualifiers on join, if any */
	 } FromExpr;
    	
    */
	FromExpr   *jointree;		/* table join tree (FROM and WHERE clauses) */

	List	   *targetList;		/* target list (of TargetEntry) */

	OverridingKind override;	/* OVERRIDING clause */

	OnConflictExpr *onConflict; /* ON CONFLICT DO [NOTHING | UPDATE] */

	List	   *returningList;	/* return-values list (of TargetEntry) */

	List	   *groupClause;	/* a list of SortGroupClause's */

	List	   *groupingSets;	/* a list of GroupingSet's if present */

	Node	   *havingQual;		/* qualifications applied to groups */

	List	   *windowClause;	/* a list of WindowClause's */

	List	   *distinctClause; /* a list of SortGroupClause's */

	List	   *sortClause;		/* a list of SortGroupClause's */

	Node	   *limitOffset;	/* # of result tuples to skip (int8 expr) */
	Node	   *limitCount;		/* # of result tuples to return (int8 expr) */

	List	   *rowMarks;		/* a list of RowMarkClause's */

	Node	   *setOperations;	/* set-operation tree if this is top level of
								 * a UNION/INTERSECT/EXCEPT query */

	List	   *constraintDeps; /* a list of pg_constraint OIDs that the query
								 * depends on to be semantically valid */

	List	   *withCheckOptions;	/* a list of WithCheckOption's (added
									 * during rewrite) */

	/*
	 * The following two fields identify the portion of the source text string
	 * containing this query.  They are typically only populated in top-level
	 * Queries, not in sub-queries.  When not set, they might both be zero, or
	 * both be -1 meaning "unknown".
	 */
	int			stmt_location;	/* start location, or -1 if unknown */
	int			stmt_len;		/* length in bytes; 0 means "rest of string" */
} Query;
```

其实分析模块的作用就是SelectStmt节点到Query节点的转换(每个分支节点也完成转换)，例如targetlist节点在SelectStmt节点中的元素Restarget节点，而在Query节点的元素是TargetEntry节点。

而完成parse tree到query tree转换工作是由pg_analyze_and_rewrite函数实现的，这个函数也完成query tree的重写工作。

#### ParseState数据结构

```c
struct ParseState
 {
     struct ParseState *parentParseState;    /* stack link */
     const char *p_sourcetext;   /* 原始sql */
     List       *p_rtable;       /* rte列表，将来成为query树范围表 */
     List       *p_joinexprs;    /* JoinExprs for RTE_JOIN p_rtable entries */
     List       *p_joinlist;     /* join items so far (will become FromExpr
                                  * node's fromlist) */
     List       *p_namespace;    /* currently-referenceable RTEs (List of
                                  * ParseNamespaceItem) */
     bool        p_lateral_active;   /* p_lateral_only items visible? */
     List       *p_ctenamespace; /* current namespace for common table exprs */
     List       *p_future_ctes;  /* common table exprs not yet in namespace */
     CommonTableExpr *p_parent_cte;  /* this query's containing CTE */
     Relation    p_target_relation;  /* INSERT/UPDATE/DELETE target rel */
     RangeTblEntry *p_target_rangetblentry;  /* target rel's RTE */
     bool        p_is_insert;    /* process assignment like INSERT not UPDATE */
     List       *p_windowdefs;   /* raw representations of window clauses */
     ParseExprKind p_expr_kind;  /* what kind of expression we're parsing */
     int         p_next_resno;   /* next targetlist resno to assign */
     List       *p_multiassign_exprs;    /* junk tlist entries for multiassign */
     List       *p_locking_clause;   /* raw FOR UPDATE/FOR SHARE info */
     bool        p_locked_from_parent;   /* parent has marked this subquery
                                          * with FOR UPDATE/FOR SHARE */
     bool        p_resolve_unknowns; /* resolve unknown-type SELECT outputs as
                                      * type text */
 
     QueryEnvironment *p_queryEnv;   /* curr env, incl refs to enclosing env */
 
     /* Flags telling about things found in the query: */
     bool        p_hasAggs;
     bool        p_hasWindowFuncs;
     bool        p_hasTargetSRFs;
     bool        p_hasSubLinks;
     bool        p_hasModifyingCTE;
 
     Node       *p_last_srf;     /* most recent set-returning func/op found */
 
     /*
      * Optional hook functions for parser callbacks.  These are null unless
      * set up by the caller of make_parsestate.
      */
     PreParseColumnRefHook p_pre_columnref_hook;
     PostParseColumnRefHook p_post_columnref_hook;
     ParseParamRefHook p_paramref_hook;
     CoerceParamHook p_coerce_param_hook;
     void       *p_ref_hook_state;   /* common passthrough link for above */
 };
```

#### Node数据结构

```c
//Node结构
typedef struct Node
{
	NodeTag		type;/* 标识节点的类型 */
} Node;
```

#### pg_analyze_and_rewrite(src/backend/tcop/postgres.c)

```c
/*
 * Given a raw parsetree (gram.y output), and optionally information about
 * types of parameter symbols ($n), perform parse analysis and rule rewriting.
 *
 * A list of Query nodes is returned, since either the analyzer or the
 * rewriter might expand one query to several.
 *
 * NOTE: for reasons mentioned above, this must be separate from raw parsing.
 */
List *
pg_analyze_and_rewrite(RawStmt *parsetree, const char *query_string,
					   Oid *paramTypes, int numParams,
					   QueryEnvironment *queryEnv)
{
	Query	   *query;
	List	   *querytree_list;

	TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);

	/*
	 * (1) Perform parse analysis.
	 */
	if (log_parser_stats)
		ResetUsage();

	query = parse_analyze(parsetree, query_string, paramTypes, numParams,
						  queryEnv);

	if (log_parser_stats)
		ShowUsage("PARSE ANALYSIS STATISTICS");

	/*
	 * (2) Rewrite the queries, as necessary
	 */
	querytree_list = pg_rewrite_query(query);

	TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);

	return querytree_list;
}
```

pg_analyze_and_rewrite函数分析和重写工作分别由parse_analyze函数和pg_rewrite_query函数来完成。

#### RangeTableEntry数据结构

```c
ypedef struct RangeTblEntry
{
	NodeTag		type;

	RTEKind		rtekind;		/* see above */

	/*
	 * XXX the fields applicable to only some rte kinds should be merged into
	 * a union.  I didn't do this yet because the diffs would impact a lot of
	 * code that is being actively worked on.  FIXME someday.
	 */

	/*
	 * Fields valid for a plain relation RTE (else zero):
	 *
	 * As a special case, RTE_NAMEDTUPLESTORE can also set relid to indicate
	 * that the tuple format of the tuplestore is the same as the referenced
	 * relation.  This allows plans referencing AFTER trigger transition
	 * tables to be invalidated if the underlying table is altered.
	 *
	 * rellockmode is really LOCKMODE, but it's declared int to avoid having
	 * to include lock-related headers here.  It must be RowExclusiveLock if
	 * the RTE is an INSERT/UPDATE/DELETE target, else RowShareLock if the RTE
	 * is a SELECT FOR UPDATE/FOR SHARE target, else AccessShareLock.
	 *
	 * Note: in some cases, rule expansion may result in RTEs that are marked
	 * with RowExclusiveLock even though they are not the target of the
	 * current query; this happens if a DO ALSO rule simply scans the original
	 * target table.  We leave such RTEs with their original lockmode so as to
	 * avoid getting an additional, lesser lock.
	 */
	Oid			relid;			/* OID of the relation */
	char		relkind;		/* relation kind (see pg_class.relkind) */
	int			rellockmode;	/* lock level that query requires on the rel */
	struct TableSampleClause *tablesample;	/* sampling info, or NULL */

	/*
	 * Fields valid for a subquery RTE (else NULL):
	 */
	Query	   *subquery;		/* the sub-query */
	bool		security_barrier;	/* is from security_barrier view? */

	/*
	 * Fields valid for a join RTE (else NULL/zero):
	 *
	 * joinaliasvars is a list of (usually) Vars corresponding to the columns
	 * of the join result.  An alias Var referencing column K of the join
	 * result can be replaced by the K'th element of joinaliasvars --- but to
	 * simplify the task of reverse-listing aliases correctly, we do not do
	 * that until planning time.  In detail: an element of joinaliasvars can
	 * be a Var of one of the join's input relations, or such a Var with an
	 * implicit coercion to the join's output column type, or a COALESCE
	 * expression containing the two input column Vars (possibly coerced).
	 * Within a Query loaded from a stored rule, it is also possible for
	 * joinaliasvars items to be null pointers, which are placeholders for
	 * (necessarily unreferenced) columns dropped since the rule was made.
	 * Also, once planning begins, joinaliasvars items can be almost anything,
	 * as a result of subquery-flattening substitutions.
	 */
	JoinType	jointype;		/* type of join */
	List	   *joinaliasvars;	/* list of alias-var expansions */

	/*
	 * Fields valid for a function RTE (else NIL/zero):
	 *
	 * When funcordinality is true, the eref->colnames list includes an alias
	 * for the ordinality column.  The ordinality column is otherwise
	 * implicit, and must be accounted for "by hand" in places such as
	 * expandRTE().
	 */
	List	   *functions;		/* list of RangeTblFunction nodes */
	bool		funcordinality; /* is this called WITH ORDINALITY? */

	/*
	 * Fields valid for a TableFunc RTE (else NULL):
	 */
	TableFunc  *tablefunc;

	/*
	 * Fields valid for a values RTE (else NIL):
	 */
	List	   *values_lists;	/* list of expression lists */

	/*
	 * Fields valid for a CTE RTE (else NULL/zero):
	 */
	char	   *ctename;		/* name of the WITH list item */
	Index		ctelevelsup;	/* number of query levels up */
	bool		self_reference; /* is this a recursive self-reference? */

	/*
	 * Fields valid for CTE, VALUES, ENR, and TableFunc RTEs (else NIL):
	 *
	 * We need these for CTE RTEs so that the types of self-referential
	 * columns are well-defined.  For VALUES RTEs, storing these explicitly
	 * saves having to re-determine the info by scanning the values_lists. For
	 * ENRs, we store the types explicitly here (we could get the information
	 * from the catalogs if 'relid' was supplied, but we'd still need these
	 * for TupleDesc-based ENRs, so we might as well always store the type
	 * info here).  For TableFuncs, these fields are redundant with data in
	 * the TableFunc node, but keeping them here allows some code sharing with
	 * the other cases.
	 *
	 * For ENRs only, we have to consider the possibility of dropped columns.
	 * A dropped column is included in these lists, but it will have zeroes in
	 * all three lists (as well as an empty-string entry in eref).  Testing
	 * for zero coltype is the standard way to detect a dropped column.
	 */
	List	   *coltypes;		/* OID list of column type OIDs */
	List	   *coltypmods;		/* integer list of column typmods */
	List	   *colcollations;	/* OID list of column collation OIDs */

	/*
	 * Fields valid for ENR RTEs (else NULL/zero):
	 */
	char	   *enrname;		/* name of ephemeral named relation */
	double		enrtuples;		/* estimated or actual from caller */

	/*
	 * Fields valid in all RTEs:
	 */
	Alias	   *alias;			/* user-written alias clause, if any */
	Alias	   *eref;			/* expanded reference names */
	bool		lateral;		/* subquery, function, or values is LATERAL? */
	bool		inh;			/* inheritance requested? */
	bool		inFromCl;		/* present in FROM clause? */
	AclMode		requiredPerms;	/* bitmask of required access permissions */
	Oid			checkAsUser;	/* if valid, check access as this role */
	Bitmapset  *selectedCols;	/* columns needing SELECT permission */
	Bitmapset  *insertedCols;	/* columns needing INSERT permission */
	Bitmapset  *updatedCols;	/* columns needing UPDATE permission */
	Bitmapset  *extraUpdatedCols;	/* generated columns being updated */
	List	   *securityQuals;	/* security barrier quals to apply, if any */
} RangeTblEntry;
```

#### Node数据结构

```c
typedef struct Node
{
	NodeTag		type;
} Node;
```

#### NodeTag数据结构

```c
/*
  * The first field of every node is NodeTag. Each node created (with makeNode)
  * will have one of the following tags as the value of its first field.
  *
  * Note that inserting or deleting node types changes the numbers of other
  * node types later in the list.  This is no problem during development, since
  * the node numbers are never stored on disk.  But don't do it in a released
  * branch, because that would represent an ABI break for extensions.
  */
 typedef enum NodeTag
 {
     T_Invalid = 0,
 
     /*
      * TAGS FOR EXECUTOR NODES (execnodes.h)
      */
     T_IndexInfo,
     T_ExprContext,
     T_ProjectionInfo,
     T_JunkFilter,
     T_OnConflictSetState,
     T_ResultRelInfo,
     T_EState,
     T_TupleTableSlot,
 
     /*
      * TAGS FOR PLAN NODES (plannodes.h)
      */
     T_Plan,
     T_Result,
     T_ProjectSet,
     T_ModifyTable,
     T_Append,
     T_MergeAppend,
     T_RecursiveUnion,
     T_BitmapAnd,
     T_BitmapOr,
     T_Scan,
     T_SeqScan,
     T_SampleScan,
     T_IndexScan,
     T_IndexOnlyScan,
     T_BitmapIndexScan,
     T_BitmapHeapScan,
     T_TidScan,
     T_SubqueryScan,
     T_FunctionScan,
     T_ValuesScan,
     T_TableFuncScan,
     T_CteScan,
     T_NamedTuplestoreScan,
     T_WorkTableScan,
     T_ForeignScan,
     T_CustomScan,
     T_Join,
     T_NestLoop,
     T_MergeJoin,
     T_HashJoin,
     T_Material,
     T_Sort,
     T_Group,
     T_Agg,
     T_WindowAgg,
     T_Unique,
     T_Gather,
     T_GatherMerge,
     T_Hash,
     T_SetOp,
     T_LockRows,
     T_Limit,
     /* these aren't subclasses of Plan: */
     T_NestLoopParam,
     T_PlanRowMark,
     T_PartitionPruneInfo,
     T_PartitionedRelPruneInfo,
     T_PartitionPruneStepOp,
     T_PartitionPruneStepCombine,
     T_PlanInvalItem,
 
     /*
      * TAGS FOR PLAN STATE NODES (execnodes.h)
      *
      * These should correspond one-to-one with Plan node types.
      */
     T_PlanState,
     T_ResultState,
     T_ProjectSetState,
     T_ModifyTableState,
     T_AppendState,
     T_MergeAppendState,
     T_RecursiveUnionState,
     T_BitmapAndState,
     T_BitmapOrState,
     T_ScanState,
     T_SeqScanState,
     T_SampleScanState,
     T_IndexScanState,
     T_IndexOnlyScanState,
     T_BitmapIndexScanState,
     T_BitmapHeapScanState,
     T_TidScanState,
     T_SubqueryScanState,
     T_FunctionScanState,
     T_TableFuncScanState,
     T_ValuesScanState,
     T_CteScanState,
     T_NamedTuplestoreScanState,
     T_WorkTableScanState,
     T_ForeignScanState,
     T_CustomScanState,
     T_JoinState,
     T_NestLoopState,
     T_MergeJoinState,
     T_HashJoinState,
     T_MaterialState,
     T_SortState,
     T_GroupState,
     T_AggState,
     T_WindowAggState,
     T_UniqueState,
     T_GatherState,
     T_GatherMergeState,
     T_HashState,
     T_SetOpState,
     T_LockRowsState,
     T_LimitState,
 
     /*
      * TAGS FOR PRIMITIVE NODES (primnodes.h)
      */
     T_Alias,
     T_RangeVar,
     T_TableFunc,
     T_Expr,
     T_Var,
     T_Const,
     T_Param,
     T_Aggref,
     T_GroupingFunc,
     T_WindowFunc,
     T_SubscriptingRef,
     T_FuncExpr,
     T_NamedArgExpr,
     T_OpExpr,
     T_DistinctExpr,
     T_NullIfExpr,
     T_ScalarArrayOpExpr,
     T_BoolExpr,
     T_SubLink,
     T_SubPlan,
     T_AlternativeSubPlan,
     T_FieldSelect,
     T_FieldStore,
     T_RelabelType,
     T_CoerceViaIO,
     T_ArrayCoerceExpr,
     T_ConvertRowtypeExpr,
     T_CollateExpr,
     T_CaseExpr,
     T_CaseWhen,
     T_CaseTestExpr,
     T_ArrayExpr,
     T_RowExpr,
     T_RowCompareExpr,
     T_CoalesceExpr,
     T_MinMaxExpr,
     T_SQLValueFunction,
     T_XmlExpr,
     T_NullTest,
     T_BooleanTest,
     T_CoerceToDomain,
     T_CoerceToDomainValue,
     T_SetToDefault,
     T_CurrentOfExpr,
     T_NextValueExpr,
     T_InferenceElem,
     T_TargetEntry,
     T_RangeTblRef,
     T_JoinExpr,
     T_FromExpr,
     T_OnConflictExpr,
     T_IntoClause,
 
     /*
      * TAGS FOR EXPRESSION STATE NODES (execnodes.h)
      *
      * ExprState represents the evaluation state for a whole expression tree.
      * Most Expr-based plan nodes do not have a corresponding expression state
      * node, they're fully handled within execExpr* - but sometimes the state
      * needs to be shared with other parts of the executor, as for example
      * with AggrefExprState, which nodeAgg.c has to modify.
      */
     T_ExprState,
     T_AggrefExprState,
     T_WindowFuncExprState,
     T_SetExprState,
     T_SubPlanState,
     T_AlternativeSubPlanState,
     T_DomainConstraintState,
 
     /*
      * TAGS FOR PLANNER NODES (pathnodes.h)
      */
     T_PlannerInfo,
     T_PlannerGlobal,
     T_RelOptInfo,
     T_IndexOptInfo,
     T_ForeignKeyOptInfo,
     T_ParamPathInfo,
     T_Path,
     T_IndexPath,
     T_BitmapHeapPath,
     T_BitmapAndPath,
     T_BitmapOrPath,
     T_TidPath,
     T_SubqueryScanPath,
     T_ForeignPath,
     T_CustomPath,
     T_NestPath,
     T_MergePath,
     T_HashPath,
     T_AppendPath,
     T_MergeAppendPath,
     T_GroupResultPath,
     T_MaterialPath,
     T_UniquePath,
     T_GatherPath,
     T_GatherMergePath,
     T_ProjectionPath,
     T_ProjectSetPath,
     T_SortPath,
     T_GroupPath,
     T_UpperUniquePath,
     T_AggPath,
     T_GroupingSetsPath,
     T_MinMaxAggPath,
     T_WindowAggPath,
     T_SetOpPath,
     T_RecursiveUnionPath,
     T_LockRowsPath,
     T_ModifyTablePath,
     T_LimitPath,
     /* these aren't subclasses of Path: */
     T_EquivalenceClass,
     T_EquivalenceMember,
     T_PathKey,
     T_PathTarget,
     T_RestrictInfo,
     T_IndexClause,
     T_PlaceHolderVar,
     T_SpecialJoinInfo,
     T_AppendRelInfo,
     T_PlaceHolderInfo,
     T_MinMaxAggInfo,
     T_PlannerParamItem,
     T_RollupData,
     T_GroupingSetData,
     T_StatisticExtInfo,
 
     /*
      * TAGS FOR MEMORY NODES (memnodes.h)
      */
     T_MemoryContext,
     T_AllocSetContext,
     T_SlabContext,
     T_GenerationContext,
 
     /*
      * TAGS FOR VALUE NODES (value.h)
      */
     T_Value,
     T_Integer,
     T_Float,
     T_String,
     T_BitString,
     T_Null,
 
     /*
      * TAGS FOR LIST NODES (pg_list.h)
      */
     T_List,
     T_IntList,
     T_OidList,
 
     /*
      * TAGS FOR EXTENSIBLE NODES (extensible.h)
      */
     T_ExtensibleNode,
 
     /*
      * TAGS FOR STATEMENT NODES (mostly in parsenodes.h)
      */
     T_RawStmt,
     T_Query,
     T_PlannedStmt,
     T_InsertStmt,
     T_DeleteStmt,
     T_UpdateStmt,
     T_SelectStmt,
     T_AlterTableStmt,
     T_AlterTableCmd,
     T_AlterDomainStmt,
     T_SetOperationStmt,
     T_GrantStmt,
     T_GrantRoleStmt,
     T_AlterDefaultPrivilegesStmt,
     T_ClosePortalStmt,
     T_ClusterStmt,
     T_CopyStmt,
     T_CreateStmt,
     T_DefineStmt,
     T_DropStmt,
     T_TruncateStmt,
     T_CommentStmt,
     T_FetchStmt,
     T_IndexStmt,
     T_CreateFunctionStmt,
     T_AlterFunctionStmt,
     T_DoStmt,
     T_RenameStmt,
     T_RuleStmt,
     T_NotifyStmt,
     T_ListenStmt,
     T_UnlistenStmt,
     T_TransactionStmt,
     T_ViewStmt,
     T_LoadStmt,
     T_CreateDomainStmt,
     T_CreatedbStmt,
     T_DropdbStmt,
     T_VacuumStmt,
     T_ExplainStmt,
     T_CreateTableAsStmt,
     T_CreateSeqStmt,
     T_AlterSeqStmt,
     T_VariableSetStmt,
     T_VariableShowStmt,
     T_DiscardStmt,
     T_CreateTrigStmt,
     T_CreatePLangStmt,
     T_CreateRoleStmt,
     T_AlterRoleStmt,
     T_DropRoleStmt,
     T_LockStmt,
     T_ConstraintsSetStmt,
     T_ReindexStmt,
     T_CheckPointStmt,
     T_CreateSchemaStmt,
     T_AlterDatabaseStmt,
     T_AlterDatabaseSetStmt,
     T_AlterRoleSetStmt,
     T_CreateConversionStmt,
     T_CreateCastStmt,
     T_CreateOpClassStmt,
     T_CreateOpFamilyStmt,
     T_AlterOpFamilyStmt,
     T_PrepareStmt,
     T_ExecuteStmt,
     T_DeallocateStmt,
     T_DeclareCursorStmt,
     T_CreateTableSpaceStmt,
     T_DropTableSpaceStmt,
     T_AlterObjectDependsStmt,
     T_AlterObjectSchemaStmt,
     T_AlterOwnerStmt,
     T_AlterOperatorStmt,
     T_DropOwnedStmt,
     T_ReassignOwnedStmt,
     T_CompositeTypeStmt,
     T_CreateEnumStmt,
     T_CreateRangeStmt,
     T_AlterEnumStmt,
     T_AlterTSDictionaryStmt,
     T_AlterTSConfigurationStmt,
     T_CreateFdwStmt,
     T_AlterFdwStmt,
     T_CreateForeignServerStmt,
     T_AlterForeignServerStmt,
     T_CreateUserMappingStmt,
     T_AlterUserMappingStmt,
     T_DropUserMappingStmt,
     T_AlterTableSpaceOptionsStmt,
     T_AlterTableMoveAllStmt,
     T_SecLabelStmt,
     T_CreateForeignTableStmt,
     T_ImportForeignSchemaStmt,
     T_CreateExtensionStmt,
     T_AlterExtensionStmt,
     T_AlterExtensionContentsStmt,
     T_CreateEventTrigStmt,
     T_AlterEventTrigStmt,
     T_RefreshMatViewStmt,
     T_ReplicaIdentityStmt,
     T_AlterSystemStmt,
     T_CreatePolicyStmt,
     T_AlterPolicyStmt,
     T_CreateTransformStmt,
     T_CreateAmStmt,
     T_CreatePublicationStmt,
     T_AlterPublicationStmt,
     T_CreateSubscriptionStmt,
     T_AlterSubscriptionStmt,
     T_DropSubscriptionStmt,
     T_CreateStatsStmt,
     T_AlterCollationStmt,
     T_CallStmt,
     T_AlterStatsStmt,
 
     /*
      * TAGS FOR PARSE TREE NODES (parsenodes.h)
      */
     T_A_Expr,
     T_ColumnRef,
     T_ParamRef,
     T_A_Const,
     T_FuncCall,
     T_A_Star,
     T_A_Indices,
     T_A_Indirection,
     T_A_ArrayExpr,
     T_ResTarget,
     T_MultiAssignRef,
     T_TypeCast,
     T_CollateClause,
     T_SortBy,
     T_WindowDef,
     T_RangeSubselect,
     T_RangeFunction,
     T_RangeTableSample,
     T_RangeTableFunc,
     T_RangeTableFuncCol,
     T_TypeName,
     T_ColumnDef,
     T_IndexElem,
     T_Constraint,
     T_DefElem,
     T_RangeTblEntry,
     T_RangeTblFunction,
     T_TableSampleClause,
     T_WithCheckOption,
     T_SortGroupClause,
     T_GroupingSet,
     T_WindowClause,
     T_ObjectWithArgs,
     T_AccessPriv,
     T_CreateOpClassItem,
     T_TableLikeClause,
     T_FunctionParameter,
     T_LockingClause,
     T_RowMarkClause,
     T_XmlSerialize,
     T_WithClause,
     T_InferClause,
     T_OnConflictClause,
     T_CommonTableExpr,
     T_RoleSpec,
     T_TriggerTransition,
     T_PartitionElem,
     T_PartitionSpec,
     T_PartitionBoundSpec,
     T_PartitionRangeDatum,
     T_PartitionCmd,
     T_VacuumRelation,
 
     /*
      * TAGS FOR REPLICATION GRAMMAR PARSE NODES (replnodes.h)
      */
     T_IdentifySystemCmd,
     T_BaseBackupCmd,
     T_CreateReplicationSlotCmd,
     T_DropReplicationSlotCmd,
     T_StartReplicationCmd,
     T_TimeLineHistoryCmd,
     T_SQLCmd,
 
     /*
      * TAGS FOR RANDOM OTHER STUFF
      *
      * These are objects that aren't part of parse/plan/execute node tree
      * structures, but we give them NodeTags anyway for identification
      * purposes (usually because they are involved in APIs where we want to
      * pass multiple object types through the same pointer).
      */
     T_TriggerData,              /* in commands/trigger.h */
     T_EventTriggerData,         /* in commands/event_trigger.h */
     T_ReturnSetInfo,            /* in nodes/execnodes.h */
     T_WindowObjectData,         /* private in nodeWindowAgg.c */
     T_TIDBitmap,                /* in nodes/tidbitmap.h */
     T_InlineCodeBlock,          /* in nodes/parsenodes.h */
     T_FdwRoutine,               /* in foreign/fdwapi.h */
     T_IndexAmRoutine,           /* in access/amapi.h */
     T_TableAmRoutine,           /* in access/tableam.h */
     T_TsmRoutine,               /* in access/tsmapi.h */
     T_ForeignKeyCacheInfo,      /* in utils/rel.h */
     T_CallContext,              /* in nodes/parsenodes.h */
     T_SupportRequestSimplify,   /* in nodes/supportnodes.h */
     T_SupportRequestSelectivity,    /* in nodes/supportnodes.h */
     T_SupportRequestCost,       /* in nodes/supportnodes.h */
     T_SupportRequestRows,       /* in nodes/supportnodes.h */
     T_SupportRequestIndexCondition  /* in nodes/supportnodes.h */
 } NodeTag;
```

####  A_Expr数据结构

```c
typedef struct A_Expr
{
	NodeTag		type;
	A_Expr_Kind kind;			/* see above */
	List	   *name;			/* possibly-qualified name of operator */
	Node	   *lexpr;			/* left argument, or NULL if none */
	Node	   *rexpr;			/* right argument, or NULL if none */
	int			location;		/* token location, or -1 if unknown */
} A_Expr;
```

#### A_Expr_Kind数据结构

```c
typedef enum A_Expr_Kind
 {
     AEXPR_OP,                   /* normal operator */
     AEXPR_OP_ANY,               /* scalar op ANY (array) */
     AEXPR_OP_ALL,               /* scalar op ALL (array) */
     AEXPR_DISTINCT,             /* IS DISTINCT FROM - name must be "=" */
     AEXPR_NOT_DISTINCT,         /* IS NOT DISTINCT FROM - name must be "=" */
     AEXPR_NULLIF,               /* NULLIF - name must be "=" */
     AEXPR_OF,                   /* IS [NOT] OF - name must be "=" or "<>" */
     AEXPR_IN,                   /* [NOT] IN - name must be "=" or "<>" */
     AEXPR_LIKE,                 /* [NOT] LIKE - name must be "~~" or "!~~" */
     AEXPR_ILIKE,                /* [NOT] ILIKE - name must be "~~*" or "!~~*" */
     AEXPR_SIMILAR,              /* [NOT] SIMILAR - name must be "~" or "!~" */
     AEXPR_BETWEEN,              /* name must be "BETWEEN" */
     AEXPR_NOT_BETWEEN,          /* name must be "NOT BETWEEN" */
     AEXPR_BETWEEN_SYM,          /* name must be "BETWEEN SYMMETRIC" */
     AEXPR_NOT_BETWEEN_SYM,      /* name must be "NOT BETWEEN SYMMETRIC" */
     AEXPR_PAREN                 /* nameless dummy node for parentheses */
 } A_Expr_Kind;
```

#### SubLink数据结构

```c
typedef struct SubLink
{
	Expr		xpr;
	SubLinkType subLinkType;	/* see above */
	int			subLinkId;		/* ID (1..n); 0 if not MULTIEXPR */
	Node	   *testexpr;		/* outer-query test for ALL/ANY/ROWCOMPARE */
	List	   *operName;		/* originally specified operator name */
	Node	   *subselect;		/* subselect as Query* or raw parsetree */
	int			location;		/* token location, or -1 if unknown */
} SubLink;
```

#### RowCompareExpr数据结构

```c
typedef struct RowCompareExpr
{
	Expr		xpr;
	RowCompareType rctype;		/* LT LE GE or GT, never EQ or NE */
	List	   *opnos;			/* OID list of pairwise comparison ops */
	List	   *opfamilies;		/* OID list of containing operator families */
	List	   *inputcollids;	/* OID list of collations for comparisons */
	List	   *largs;			/* the left-hand input arguments */
	List	   *rargs;			/* the right-hand input arguments */
} RowCompareExpr;
```

##### 查看函数堆栈

```bash
(gdb) bt
#0  parse_analyze (parseTree=0x2a92a88, sourceText=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at analyze.c:104
#1  0x00000000008e03d1 in pg_analyze_and_rewrite (parsetree=0x2a92a88, query_string=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:695
#2  0x00000000008e0a15 in exec_simple_query (query_string=0x2a91e98 "select 1;") at postgres.c:1140
#3  0x00000000008e4e0e in PostgresMain (argc=1, argv=0x2abbfa8, dbname=0x2abbe08 "postgres", username=0x2abbde0 "postgres") at postgres.c:4236
#4  0x000000000083bb0c in BackendRun (port=0x2ab3dc0) at postmaster.c:4431
#5  0x000000000083b2ea in BackendStartup (port=0x2ab3dc0) at postmaster.c:4122
#6  0x00000000008376e1 in ServerLoop () at postmaster.c:1704
#7  0x0000000000836f97 in PostmasterMain (argc=3, argv=0x2a8cae0) at postmaster.c:1377
#8  0x0000000000758833 in main (argc=3, argv=0x2a8cae0) at main.c:228
```

##### parse_analyze(src/backend/parser/analyze.c)

```c
/*
	完成分析工作
*/
Query *
parse_analyze(RawStmt *parseTree, const char *sourceText,
			  Oid *paramTypes, int numParams,
			  QueryEnvironment *queryEnv)
{
	ParseState *pstate = make_parsestate(NULL);
	Query	   *query;

	Assert(sourceText != NULL); /* required as of 8.4 */

	pstate->p_sourcetext = sourceText;

	if (numParams > 0)
		parse_fixed_parameters(pstate, paramTypes, numParams);

	pstate->p_queryEnv = queryEnv;
    //调用transformTopLevelStmt函数完成parsetree到query tree的工作
	query = transformTopLevelStmt(pstate, parseTree);

	if (post_parse_analyze_hook)
		(*post_parse_analyze_hook) (pstate, query);

	free_parsestate(pstate);

	return query;
}
```

##### transformTopLevelStmt(src/backend/parser/analyze.c)

```c
Query *
transformTopLevelStmt(ParseState *pstate, RawStmt *parseTree)
{
	Query	   *result;

	/* We're at top level, so allow SELECT INTO */
    //调用了transformOptionalSelectInto函数
	result = transformOptionalSelectInto(pstate, parseTree->stmt);

	result->stmt_location = parseTree->stmt_location;
	result->stmt_len = parseTree->stmt_len;

	return result;
}
```

##### transformOptionalSelectInto(src/backend/parser/analyze.c)

```c
/*
 * transformOptionalSelectInto -
 *	  If SELECT has INTO, convert it to CREATE TABLE AS.
 *
 * The only thing we do here that we don't do in transformStmt() is to
 * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements
 * aren't allowed within larger statements, this is only allowed at the top
 * of the parse tree, and so we only try it before entering the recursive
 * transformStmt() processing.
 */
/*
	该函数首先判断是不是select into,
		如果是select into将select into(SelectStmt)转换create table as(CreateTableAsStmt)
		如果不是，就交给transformStmt来完成。(其他的Select类型都是由这这个函数来处理的)
*/
static Query *
transformOptionalSelectInto(ParseState *pstate, Node *parseTree)
{
	if (IsA(parseTree, SelectStmt))
	{
		SelectStmt *stmt = (SelectStmt *) parseTree;

		/* If it's a set-operation tree, drill down to leftmost SelectStmt */
		while (stmt && stmt->op != SETOP_NONE)
			stmt = stmt->larg;
		Assert(stmt && IsA(stmt, SelectStmt) &&stmt->larg == NULL);

		if (stmt->intoClause)
		{
			CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);

			ctas->query = parseTree;
			ctas->into = stmt->intoClause;
			ctas->relkind = OBJECT_TABLE;
			ctas->is_select_into = true;

			/*
			 * Remove the intoClause from the SelectStmt.  This makes it safe
			 * for transformSelectStmt to complain if it finds intoClause set
			 * (implying that the INTO appeared in a disallowed place).
			 */
			stmt->intoClause = NULL;

			parseTree = (Node *) ctas;
		}
	}

	return transformStmt(pstate, parseTree);
}
```

#####  transformStmt(src/backend/parser/analyze.c)

```c
 /*
 * transformStmt -
 *	  recursively transform a Parse tree into a Query tree.
 */
Query *
transformStmt(ParseState *pstate, Node *parseTree)
{
	Query	   *result;

	/*
	 * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;
	 * we can't just run it on everything because raw_expression_tree_walker()
	 * doesn't claim to handle utility statements.
	 */
#ifdef RAW_EXPRESSION_COVERAGE_TEST
	switch (nodeTag(parseTree))
	{
		case T_SelectStmt:
		case T_InsertStmt:
		case T_UpdateStmt:
		case T_DeleteStmt:
			(void) test_raw_expression_coverage(parseTree, NULL);
			break;
		default:
			break;
	}
#endif							/* RAW_EXPRESSION_COVERAGE_TEST */

	switch (nodeTag(parseTree))
	{
			/*
			 * Optimizable statements
			 */
		case T_InsertStmt:
			result = transformInsertStmt(pstate, (InsertStmt *) parseTree);
			break;

		case T_DeleteStmt:
			result = transformDeleteStmt(pstate, (DeleteStmt *) parseTree);
			break;

		case T_UpdateStmt:
			result = transformUpdateStmt(pstate, (UpdateStmt *) parseTree);
			break;

   		case T_SelectStmt:
			{
				SelectStmt *n = (SelectStmt *) parseTree;

				if (n->valuesLists)
					result = transformValuesClause(pstate, n);
				else if (n->op == SETOP_NONE)
					result = transformSelectStmt(pstate, n);
				else
					result = transformSetOperationStmt(pstate, n);
			}
			break;

			/*
			 * Special cases
			 */
		case T_DeclareCursorStmt:
			result = transformDeclareCursorStmt(pstate,
												(DeclareCursorStmt *) parseTree);
			break;

		case T_ExplainStmt:
			result = transformExplainStmt(pstate,
										  (ExplainStmt *) parseTree);
			break;

		case T_CreateTableAsStmt:
			result = transformCreateTableAsStmt(pstate,
												(CreateTableAsStmt *) parseTree);
			break;

		case T_CallStmt:
			result = transformCallStmt(pstate,
									   (CallStmt *) parseTree);
			break;

		default:

			/*
			 * other statements don't require any transformation; just return
			 * the original parsetree with a Query node plastered on top.
			 */
			result = makeNode(Query);
			result->commandType = CMD_UTILITY;
			result->utilityStmt = (Node *) parseTree;
			break;
	}

	/* Mark as original query until we learn differently */
	result->querySource = QSRC_ORIGINAL;
	result->canSetTag = true;

	return result;
}
```

接下来通过完整的示例看整个查询执行流程:

### CASE SELECT	

```sql
postgres=# select classno,classname,avg(score) as avg_score from sc,(select * from class where class.gno='grade one') as sub where sc.sno in (select sno from student where student.classno=sub.classno) and sc.cno in (select course.cno from course where course.cname='database') group by classno,classname having avg(score)>60 order by avg_score;
```

#### 调用堆栈

```
#0  transformSelectStmt (pstate=0x2a92b20, stmt=0x2a92970) at analyze.c:1200
#1  0x00000000005c32ef in transformStmt (pstate=0x2a92b20, parseTree=0x2a92970) at analyze.c:301
#2  0x00000000005c31ca in transformOptionalSelectInto (pstate=0x2a92b20, parseTree=0x2a92970) at analyze.c:246
#3  0x00000000005c3088 in transformTopLevelStmt (pstate=0x2a92b20, parseTree=0x2a92a88) at analyze.c:196
#4  0x00000000005c2ee0 in parse_analyze (parseTree=0x2a92a88, sourceText=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at analyze.c:116
#5  0x00000000008e03d1 in pg_analyze_and_rewrite (parsetree=0x2a92a88, query_string=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:695
#6  0x00000000008e0a15 in exec_simple_query (query_string=0x2a91e98 "select 1;") at postgres.c:1140
#7  0x00000000008e4e0e in PostgresMain (argc=1, argv=0x2abbfa8, dbname=0x2abbe08 "postgres", username=0x2abbde0 "postgres") at postgres.c:4236
#8  0x000000000083bb0c in BackendRun (port=0x2ab3dc0) at postmaster.c:4431
#9  0x000000000083b2ea in BackendStartup (port=0x2ab3dc0) at postmaster.c:4122
#10 0x00000000008376e1 in ServerLoop () at postmaster.c:1704
#11 0x0000000000836f97 in PostmasterMain (argc=3, argv=0x2a8cae0) at postmaster.c:1377
#12 0x0000000000758833 in main (argc=3, argv=0x2a8cae0) at main.c:228
```

#### 流程分析

```C
Query *
transformStmt(ParseState *pstate, Node *parseTree)
    /*
    	pstate->p_sourcetext="pasretree对应的原始sql"
    	parseTree->type=T_SelectStmt;
    */
{
	Query	   *result;
    //nodeTag(parseTree)=T_SelectStmt
	switch (nodeTag(parseTree))
	{
		case T_SelectStmt:
			{
				SelectStmt *n = (SelectStmt *) parseTree;
				//判断是不是值表达式，如果是由transformValuesClause来处理
				if (n->valuesLists)
					result = transformValuesClause(pstate, n);
                //如果Select语句中不含集合操作时，由transformSelectStmt来处理，否则由transformSetOperationStmt来处理（这里进入transformSelectStmt函数)
				else if (n->op == SETOP_NONE)
					result = transformSelectStmt(pstate, n);
				else
					result = transformSetOperationStmt(pstate, n);
			}
			break;
	}

	/* 标记为原始查询树 */
	result->querySource = QSRC_ORIGINAL;//该查询树来自parse tree
	result->canSetTag = true;

	return result;
}
```

#### transformSelectStmt(src/backend/parser/analyze.c)

```c
/*
 * transformSelectStmt -
 *	  transforms a Select Statement
 *
 * Note: this covers only cases with no set operations and no VALUES lists;
 * see below for the other cases.
 */
static Query *
transformSelectStmt(ParseState *pstate, SelectStmt *stmt)
{
	Query	   *qry = makeNode(Query);//生成新的Query节点qry
	Node	   *qual;
	ListCell   *l;

	qry->commandType = CMD_SELECT;//设置SQL语句的类型

	/* process the WITH clause independently of all else */
	if (stmt->withClause)
	{
		qry->hasRecursive = stmt->withClause->recursive;
		qry->cteList = transformWithClause(pstate, stmt->withClause);
		qry->hasModifyingCTE = pstate->p_hasModifyingCTE;
	}

	/* Complain if we get called from someplace where INTO is not allowed */
	if (stmt->intoClause)
		ereport(ERROR,
				(errcode(ERRCODE_SYNTAX_ERROR),
				 errmsg("SELECT ... INTO is not allowed here"),
				 parser_errposition(pstate,
									exprLocation((Node *) stmt->intoClause))));

	/* make FOR UPDATE/FOR SHARE info available to addRangeTableEntry */
	pstate->p_locking_clause = stmt->lockingClause;

	/* make WINDOW info available for window functions, too */
	pstate->p_windowdefs = stmt->windowClause;

	/* process the FROM clause */
	transformFromClause(pstate, stmt->fromClause);

	/* transform targetlist */
	qry->targetList = transformTargetList(pstate, stmt->targetList,
										  EXPR_KIND_SELECT_TARGET);

	/* mark column origins */
	markTargetListOrigins(pstate, qry->targetList);

	/* transform WHERE */
	qual = transformWhereClause(pstate, stmt->whereClause,
								EXPR_KIND_WHERE, "WHERE");

	/* initial processing of HAVING clause is much like WHERE clause */
	qry->havingQual = transformWhereClause(pstate, stmt->havingClause,
										   EXPR_KIND_HAVING, "HAVING");

	/*
	 * Transform sorting/grouping stuff.  Do ORDER BY first because both
	 * transformGroupClause and transformDistinctClause need the results. Note
	 * that these functions can also change the targetList, so it's passed to
	 * them by reference.
	 */
	qry->sortClause = transformSortClause(pstate,
										  stmt->sortClause,
										  &qry->targetList,
										  EXPR_KIND_ORDER_BY,
										  false /* allow SQL92 rules */ );

	qry->groupClause = transformGroupClause(pstate,
											stmt->groupClause,
											&qry->groupingSets,
											&qry->targetList,
											qry->sortClause,
											EXPR_KIND_GROUP_BY,
											false /* allow SQL92 rules */ );

	if (stmt->distinctClause == NIL)
	{
		qry->distinctClause = NIL;
		qry->hasDistinctOn = false;
	}
	else if (linitial(stmt->distinctClause) == NULL)
	{
		/* We had SELECT DISTINCT */
		qry->distinctClause = transformDistinctClause(pstate,
													  &qry->targetList,
													  qry->sortClause,
													  false);
		qry->hasDistinctOn = false;
	}
	else
	{
		/* We had SELECT DISTINCT ON */
		qry->distinctClause = transformDistinctOnClause(pstate,
														stmt->distinctClause,
														&qry->targetList,
														qry->sortClause);
		qry->hasDistinctOn = true;
	}

	/* transform LIMIT */
	qry->limitOffset = transformLimitClause(pstate, stmt->limitOffset,
											EXPR_KIND_OFFSET, "OFFSET");
	qry->limitCount = transformLimitClause(pstate, stmt->limitCount,
										   EXPR_KIND_LIMIT, "LIMIT");

	/* transform window clauses after we have seen all window functions */
	qry->windowClause = transformWindowDefinitions(pstate,
												   pstate->p_windowdefs,
												   &qry->targetList);

	/* resolve any still-unresolved output columns as being type text */
	if (pstate->p_resolve_unknowns)
		resolveTargetListUnknowns(pstate, qry->targetList);

	qry->rtable = pstate->p_rtable;
	qry->jointree = makeFromExpr(pstate->p_joinlist, qual);

	qry->hasSubLinks = pstate->p_hasSubLinks;
	qry->hasWindowFuncs = pstate->p_hasWindowFuncs;
	qry->hasTargetSRFs = pstate->p_hasTargetSRFs;
	qry->hasAggs = pstate->p_hasAggs;

	foreach(l, stmt->lockingClause)
	{
		transformLockingClause(pstate, qry,
							   (LockingClause *) lfirst(l), false);
	}

	assign_query_collations(pstate, qry);

	/* this must be done after collations, for reliable comparison of exprs */
	if (pstate->p_hasAggs || qry->groupClause || qry->groupingSets || qry->havingQual)
		parseCheckAggregates(pstate, qry);

	return qry;
}
```

显然，按Select语句中每个子句的类型分类处理。

##### transformFromClause(src/backend/parser/parse_clause.c)

```c
/*
	处理from子句并向ParseState添加range table,joinlist, and namespace项.
*/
void
transformFromClause(ParseState *pstate, List *frmList)
{
	ListCell   *fl;

	/*
	 * The grammar will have produced a list of RangeVars, RangeSubselects,
	 * RangeFunctions, and/or JoinExprs. Transform each one (possibly adding
	 * entries to the rtable), check for duplicate refnames, and then add it
	 * to the joinlist and namespace.
	 *
	 * Note we must process the items left-to-right for proper handling of
	 * LATERAL references.
	 */
    /*
    	遍历fromlist中的每个元素，交给transformFromClauseItem处理。
    	该函数进行分类处理(基表、子查询、函数)，每个类别的元素都有相应的函数进行处理。
    */
	foreach(fl, frmList)
	{
		Node	   *n = lfirst(fl);
		RangeTblEntry *rte;
		int			rtindex;
		List	   *namespace;

		n = transformFromClauseItem(pstate, n,
									&rte,
									&rtindex,
									&namespace);

		checkNameSpaceConflicts(pstate, pstate->p_namespace, namespace);

		/* Mark the new namespace items as visible only to LATERAL */
		setNamespaceLateralState(namespace, true, true);

        //关系表以RangeTblRef的形式加入到joinlist
        //关系表以RangeTbaleEntry的形式加入到namespace
		pstate->p_joinlist = lappend(pstate->p_joinlist, n);
		pstate->p_namespace = list_concat(pstate->p_namespace, namespace);
	}

	/*
	 * We're done parsing the FROM list, so make all namespace items
	 * unconditionally visible.  Note that this will also reset lateral_only
	 * for any namespace items that were already present when we were called;
	 * but those should have been that way already.
	 */
	setNamespaceLateralState(pstate->p_namespace, false, true);
}
```

###### transformFromClauseItem(src/backend/parser/parse_clause.c)

```c
// 处理普通关系表(transformTableEntry)
/* 
	将fromlist中的元素(关系表)以RangeTableEntry形式加入到parseState的p_rtable中，后续需要访问
	基表就用p_rtable,
	
	为了能够快速从p_rtable中获得基表的信息，对于每个加入到p_rtable(将来形成query tree的rtable)中的RangeTbaleEntry分配一个唯一索引rtindex，rtindex以RangeTlbRef形式封装到ParseState的joinlist中去(将来形成FromExpr node's fromlist).
	
	所以RangeTbaleEntry和RangeTlbRef一一对应。
*/
//判断fromlist元素是不是RangeVar类型
if (IsA(n, RangeVar))
	{
		/* Plain relation reference, or perhaps a CTE reference */
		RangeVar   *rv = (RangeVar *) n;
		RangeTblRef *rtr;
		RangeTblEntry *rte;
		int			rtindex;

		/* Check if it's a CTE or tuplestore reference */
    	//判断是否是CTE或者特殊关系类型
		rte = getRTEForSpecialRelationTypes(pstate, rv);
		//如果不是，元素为普通关系表，由transformTableEntry处理
		/* if not found above, must be a table reference */
		if (!rte)
			rte = transformTableEntry(pstate, rv);

		/* assume new rte is at end */
		rtindex = list_length(pstate->p_rtable);
		Assert(rte == rt_fetch(rtindex, pstate->p_rtable));
		*top_rte = rte;
		*top_rti = rtindex;
		*namespace = list_make1(makeDefaultNSItem(rte));
		rtr = makeNode(RangeTblRef);
		rtr->rtindex = rtindex;
		return (Node *) rtr;
	}


// 处理子查询(transformRangeSubselect)
/*
	 子查询也是完整的查询语句，所以先用函数parse_sub_analyze(将子查询先分析成query树)，然后再用
	  addRangeTableEntryForSubquery函数，将子查询(query tree)作为整体以RangTableEntry类型加入到p_rtable中(过程和关系表相同)。
	  
	 有一点区别在于:RTEKind
	 	关系表的RTEkind=RTE_RELATION
	 	子查询的RTEKind=RTE_SUBQUERY
	 	
*/
else if (IsA(n, RangeSubselect))
	{
		/* sub-SELECT is like a plain relation */
		RangeTblRef *rtr;
		RangeTblEntry *rte;
		int			rtindex;

		rte = transformRangeSubselect(pstate, (RangeSubselect *) n);
		/* assume new rte is at end */
		rtindex = list_length(pstate->p_rtable);
		Assert(rte == rt_fetch(rtindex, pstate->p_rtable));
		*top_rte = rte;
		*top_rti = rtindex;
		*namespace = list_make1(makeDefaultNSItem(rte));
		rtr = makeNode(RangeTblRef);
		rtr->rtindex = rtindex;
		return (Node *) rtr;
	}
// 其他类型的from子句同样有相应的函数处理
```

###### transformTableEntry(src/backend/parser/parse_clause.c)

```c
static RangeTblEntry *
transformTableEntry(ParseState *pstate, RangeVar *r)
{
	RangeTblEntry *rte;

	/* We need only build a range table entry */
	rte = addRangeTableEntry(pstate, r, r->alias, r->inh, true);

	return rte;
}


RangeTblEntry *
addRangeTableEntry(ParseState *pstate,
				   RangeVar *relation,
				   Alias *alias,
				   bool inh,
				   bool inFromCl)
{
	RangeTblEntry *rte = makeNode(RangeTblEntry);
	char	   *refname = alias ? alias->aliasname : relation->relname;
	LOCKMODE	lockmode;
	Relation	rel;

	Assert(pstate != NULL);

	rte->rtekind = RTE_RELATION;
	rte->alias = alias;

	/*
	 * 确定我们在这个关系上需要的锁的类型.  It's not the
	 * query's target table (that case is handled elsewhere), so we need
	 * either RowShareLock if it's locked by FOR UPDATE/SHARE, or plain
	 * AccessShareLock otherwise.
	 */
	lockmode = isLockedRefname(pstate, refname) ? RowShareLock : AccessShareLock;
    
	/*
		获取关系表的OID
	 * Get the rel's OID.  This access also ensures that we have an up-to-date
	 * relcache entry for the rel.  Since this is typically the first access
	 * to a rel in a statement, we must open the rel with the proper lockmode.
	 */
	rel = parserOpenTable(pstate, relation, lockmode);
	rte->relid = RelationGetRelid(rel);
	rte->relkind = rel->rd_rel->relkind;
	rte->rellockmode = lockmode;

	/*
	 * Build the list of effective column names using user-supplied aliases
	 * and/or actual column names.
	 */
	rte->eref = makeAlias(refname, NIL);
	buildRelationAliases(rel->rd_att, alias, rte->eref);

	/*
	 * Drop the rel refcount, but keep the access lock till end of transaction
	 * so that the table can't be deleted or have its schema modified
	 * underneath us.
	 */
	table_close(rel, NoLock);

	/*
	 * Set flags and access permissions.
	 *
	 * The initial default on access checks is always check-for-READ-access,
	 * which is the right thing for all except target tables.
	 */
	rte->lateral = false;
	rte->inh = inh;
	rte->inFromCl = inFromCl;

	rte->requiredPerms = ACL_SELECT;
	rte->checkAsUser = InvalidOid;	/* not set-uid by default, either */
	rte->selectedCols = NULL;
	rte->insertedCols = NULL;
	rte->updatedCols = NULL;
	rte->extraUpdatedCols = NULL;

	/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */
    /*将fromlist中的元素以RangeTableEntry形式加入到parseState的p_rtable中，
    	但是现在不添加到joinlist和namespace中去，在合适的时机做这个操作
    */
	pstate->p_rtable = lappend(pstate->p_rtable, rte);

	return rte;
}
```

###### transformRangeSubselect(src/backend/parser/parse_clause.c)

```c
/*
  * transformRangeSubselect --- transform a sub-SELECT appearing in FROM
  */
 static RangeTblEntry *
 transformRangeSubselect(ParseState *pstate, RangeSubselect *r)
 {
     Query      *query;
     RangeTblEntry *rte;
 
     /*
      * We require user to supply an alias for a subselect, per SQL92. To relax
      * this, we'd have to be prepared to gin up a unique alias for an
      * unlabeled subselect.  (This is just elog, not ereport, because the
      * grammar should have enforced it already.  It'd probably be better to
      * report the error here, but we don't have a good error location here.)
      */
     //检查子查询是否有别名
     if (r->alias == NULL)
         elog(ERROR, "subquery in FROM must have an alias");
 
     /*
      * Set p_expr_kind to show this parse level is recursing to a subselect.
      * We can't be nested within any expression, so don't need save-restore
      * logic here.
      */
     Assert(pstate->p_expr_kind == EXPR_KIND_NONE);
     pstate->p_expr_kind = EXPR_KIND_FROM_SUBSELECT;
 
     /*
      * If the subselect is LATERAL, make lateral_only names of this level
      * visible to it.  (LATERAL can't nest within a single pstate level, so we
      * don't need save/restore logic here.)
      */
     Assert(!pstate->p_lateral_active);
     pstate->p_lateral_active = r->lateral;
 
     /*
      * Analyze and transform the subquery.
      */
     query = parse_sub_analyze(r->subquery, pstate, NULL,
                               isLockedRefname(pstate, r->alias->aliasname),
                               true);
 
     /* Restore state */
     pstate->p_lateral_active = false;
     pstate->p_expr_kind = EXPR_KIND_NONE;
 
     /*
      * Check that we got a SELECT.  Anything else should be impossible given
      * restrictions of the grammar, but check anyway.
      */
     if (!IsA(query, Query) ||
         query->commandType != CMD_SELECT)
         elog(ERROR, "unexpected non-SELECT command in subquery in FROM");
 
     /*
      * OK, build an RTE for the subquery.
      */
     rte = addRangeTableEntryForSubquery(pstate,
                                         query,
                                         r->alias,
                                         r->lateral,
                                         true);
 
     return rte;
 }
```

到此from子句就已经分析完毕。

##### transformTargetList(src/backend/parser/parse_target.c)

```c
/*
	相关的数据结构:
	typedef struct ColumnRef
	{
		NodeTag		type;
		List	   *fields;			/* field names (Value strings) or A_Star */
		int			location;		/* token location, or -1 if unknown */
	} ColumnRef;
	
*/
/* transform targetlist */
	qry->targetList = transformTargetList(pstate, stmt->targetList,
										  EXPR_KIND_SELECT_TARGET);
/*
  * transformTargetList()
  * Turns a list of ResTarget's into a list of TargetEntry's.
  *
  * This code acts mostly the same for SELECT, UPDATE, or RETURNING lists;
  * the main thing is to transform the given expressions (the "val" fields).
  * The exprKind parameter distinguishes these cases when necessary.
  */

/*
	完成selectstmt中的targetlist(list中的元素以ResTartget类型存在)转换为query中的targetlist(list中的元素以TargetEntry存在)
	
	typedef struct ResTarget
	{
		NodeTag		type;
		char	   *name;			/* column name or NULL */
		List	   *indirection;	/* subscripts, field names, and '*', or NIL */
		Node	   *val;			/* the value expression to compute or assign */
		int			location;		/* token location, or -1 if unknown */
	} ResTarget;

	这个数据结构在select、insert、update都被使用但含义不一样
	select中:
		name:列名的别名
		val:值表达式
		indirection：在select中不可用
	
	insert中:
		name:目标列名
		val:不可用
		indirection:目标列的下标
		
	update中:
		name:目标列名
		val:值表达式
		indirection:目标列的下标
		
*/


/*
   如果包含*号由函数ExpandColumnRefStar和ExpandIndirectionStar完成*号的扩展并转换为targetEntry；
   如果不包含*号则函数transformTargetEntry将Restarget转换为targetEntry
	
	
	函数scanRTEForColumn完成目标列的明确性检查，明确该列属于那个基表
*/
 List *
 transformTargetList(ParseState *pstate, List *targetlist,
                     ParseExprKind exprKind)
 {
     List       *p_target = NIL;
     bool        expand_star;
     ListCell   *o_target;
 
     /* Shouldn't have any leftover multiassign items at start */
     Assert(pstate->p_multiassign_exprs == NIL);
 
     /* Expand "something.*" in SELECT and RETURNING, but not UPDATE */
     expand_star = (exprKind != EXPR_KIND_UPDATE_SOURCE);
 
     foreach(o_target, targetlist)
     {
         ResTarget  *res = (ResTarget *) lfirst(o_target);
 
         /*
          * Check for "something.*".  Depending on the complexity of the
          * "something", the star could appear as the last field in ColumnRef,
          * or as the last indirection item in A_Indirection.
          */
         /*
         	*可以出现的位置是ColumnRef的fileld(包含列名或者*)最后一个元素，或者A_Indirection的
         	Indirection(例如数组下标)的最后一个元素
         */
         if (expand_star)
         {
             //如果是普通列,并且是*号，调用函数ExpandColumnRefStar扩展*号
             if (IsA(res->val, ColumnRef))
             {
                 ColumnRef  *cref = (ColumnRef *) res->val;
 				
                 if (IsA(llast(cref->fields), A_Star))
                 {
                     /* It is something.*, expand into multiple items */
                     p_target = list_concat(p_target,
                                            ExpandColumnRefStar(pstate,
                                                                cref,
                                                                true));
                     continue;
                 }
             }
             //如果该列是数组等类型，Indirection可能为数组下标或者*号，如果是*号
             //由函数ExpandIndirectionStar来处理
             else if (IsA(res->val, A_Indirection))
             {
                 A_Indirection *ind = (A_Indirection *) res->val;
 
                 if (IsA(llast(ind->indirection), A_Star))
                 {
                     /* It is something.*, expand into multiple items */
                     p_target = list_concat(p_target,
                                            ExpandIndirectionStar(pstate,
                                                                  ind,
                                                                  true,
                                                                  exprKind));
                     continue;
                 }
             }
         }
 
         /*
          * Not "something.*", or we want to treat that as a plain whole-row
          * variable, so transform as a single expression
          */
         //不包含*号的处理流程
         p_target = lappend(p_target,
                            transformTargetEntry(pstate,
                                                 res->val,
                                                 NULL,
                                                 exprKind,
                                                 res->name,
                                                 false));
     }
 
     /*
      * If any multiassign resjunk items were created, attach them to the end
      * of the targetlist.  This should only happen in an UPDATE tlist.  We
      * don't need to worry about numbering of these items; transformUpdateStmt
      * will set their resnos.
      */
     if (pstate->p_multiassign_exprs)
     {
         Assert(exprKind == EXPR_KIND_UPDATE_SOURCE);
         p_target = list_concat(p_target, pstate->p_multiassign_exprs);
         pstate->p_multiassign_exprs = NIL;
     }
 
     return p_target;
 }
```

###### ExpandColumnRefStar(src/backend/parser/parse_target.c）

```c
/*
 * ExpandColumnRefStar()
 *		Transforms foo.* into a list of expressions or targetlist entries.
 *
 * This handles the case where '*' appears as the last or only item in a
 * ColumnRef.  The code is shared between the case of foo.* at the top level
 * in a SELECT target list (where we want TargetEntry nodes in the result)
 * and foo.* in a ROW() or VALUES() construct (where we want just bare
 * expressions).
 *
 * The referenced columns are marked as requiring SELECT access.
 */
static List *
ExpandColumnRefStar(ParseState *pstate, ColumnRef *cref,
					bool make_target_entry)
{
	List	   *fields = cref->fields;
	int			numnames = list_length(fields);

    //如果target item只有单独*号，调用ExpandAllTables函数处理
	if (numnames == 1)
	{
		/*
		 * Target item is a bare '*', expand all tables
		 *
		 * (e.g., SELECT * FROM emp, dept)
		 *
		 * Since the grammar only accepts bare '*' at top level of SELECT, we
		 * need not handle the make_target_entry==false case here.
		 */
		Assert(make_target_entry);
		return ExpandAllTables(pstate, cref->location);
	}
	else
	{
		/*
		 * Target item is relation.*, expand that table
		 *
		 * (e.g., SELECT emp.*, dname FROM emp, dept)
		 *
		 * Note: this code is a lot like transformColumnRef; it's tempting to
		 * call that instead and then replace the resulting whole-row Var with
		 * a list of Vars.  However, that would leave us with the RTE's
		 * selectedCols bitmap showing the whole row as needing select
		 * permission, as well as the individual columns.  That would be
		 * incorrect (since columns added later shouldn't need select
		 * permissions).  We could try to remove the whole-row permission bit
		 * after the fact, but duplicating code is less messy.
		 */
		char	   *nspname = NULL;
		char	   *relname = NULL;
		RangeTblEntry *rte = NULL;
		int			levels_up;
		enum
		{
			CRSERR_NO_RTE,
			CRSERR_WRONG_DB,
			CRSERR_TOO_MANY
		}			crserr = CRSERR_NO_RTE;

		/*
		 * Give the PreParseColumnRefHook, if any, first shot.  If it returns
		 * non-null then we should use that expression.
		 */
		if (pstate->p_pre_columnref_hook != NULL)
		{
			Node	   *node;

			node = pstate->p_pre_columnref_hook(pstate, cref);
			if (node != NULL)
				return ExpandRowReference(pstate, node, make_target_entry);
		}

		switch (numnames)
		{
			case 2:
				relname = strVal(linitial(fields));
				rte = refnameRangeTblEntry(pstate, nspname, relname,
										   cref->location,
										   &levels_up);
				break;
			case 3:
				nspname = strVal(linitial(fields));
				relname = strVal(lsecond(fields));
				rte = refnameRangeTblEntry(pstate, nspname, relname,
										   cref->location,
										   &levels_up);
				break;
			case 4:
				{
					char	   *catname = strVal(linitial(fields));

					/*
					 * We check the catalog name and then ignore it.
					 */
					if (strcmp(catname, get_database_name(MyDatabaseId)) != 0)
					{
						crserr = CRSERR_WRONG_DB;
						break;
					}
					nspname = strVal(lsecond(fields));
					relname = strVal(lthird(fields));
					rte = refnameRangeTblEntry(pstate, nspname, relname,
											   cref->location,
											   &levels_up);
					break;
				}
			default:
				crserr = CRSERR_TOO_MANY;
				break;
		}

		/*
		 * Now give the PostParseColumnRefHook, if any, a chance. We cheat a
		 * bit by passing the RangeTblEntry, not a Var, as the planned
		 * translation.  (A single Var wouldn't be strictly correct anyway.
		 * This convention allows hooks that really care to know what is
		 * happening.)
		 */
		if (pstate->p_post_columnref_hook != NULL)
		{
			Node	   *node;

			node = pstate->p_post_columnref_hook(pstate, cref,
												 (Node *) rte);
			if (node != NULL)
			{
				if (rte != NULL)
					ereport(ERROR,
							(errcode(ERRCODE_AMBIGUOUS_COLUMN),
							 errmsg("column reference \"%s\" is ambiguous",
									NameListToString(cref->fields)),
							 parser_errposition(pstate, cref->location)));
				return ExpandRowReference(pstate, node, make_target_entry);
			}
		}

		/*
		 * Throw error if no translation found.
		 */
		if (rte == NULL)
		{
			switch (crserr)
			{
				case CRSERR_NO_RTE:
					errorMissingRTE(pstate, makeRangeVar(nspname, relname,
														 cref->location));
					break;
				case CRSERR_WRONG_DB:
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("cross-database references are not implemented: %s",
									NameListToString(cref->fields)),
							 parser_errposition(pstate, cref->location)));
					break;
				case CRSERR_TOO_MANY:
					ereport(ERROR,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("improper qualified name (too many dotted names): %s",
									NameListToString(cref->fields)),
							 parser_errposition(pstate, cref->location)));
					break;
			}
		}

		/*
		 * OK, expand the RTE into fields.
		 */
		return ExpandSingleTable(pstate, rte, cref->location, make_target_entry);
	}
}
```

ExpandAllTables(src/backend/parser/parse_target.c)

```c
static List *
ExpandAllTables(ParseState *pstate, int location)
{
	List	   *target = NIL;
	bool		found_table = false;
	ListCell   *l;

    /*
    	遍历pstate->p_namespace中的每个RangeTableEntry,使用expandRelAttr函数扩展该RangeTableEntry		中的所有列。
    */
    
	foreach(l, pstate->p_namespace)
	{
		ParseNamespaceItem *nsitem = (ParseNamespaceItem *) lfirst(l);
		RangeTblEntry *rte = nsitem->p_rte;

		/* Ignore table-only items */
		if (!nsitem->p_cols_visible)
			continue;
		/* Should not have any lateral-only items when parsing targetlist */
		Assert(!nsitem->p_lateral_only);
		/* Remember we found a p_cols_visible item */
		found_table = true;

		target = list_concat(target,
							 expandRelAttrs(pstate,
											rte,
											RTERangeTablePosn(pstate, rte,
															  NULL),
											0,
											location));
	}

	/*
	 * Check for "SELECT *;".  We do it this way, rather than checking for
	 * target == NIL, because we want to allow SELECT * FROM a zero_column
	 * table.
	 */
	if (!found_table)
		ereport(ERROR,
				(errcode(ERRCODE_SYNTAX_ERROR),
				 errmsg("SELECT * with no tables specified is not valid"),
				 parser_errposition(pstate, location)));

	return target;
}


//最终调用expandRelAttrs函数扩展RangeTabletEntry中的所有列

/*
 * expandRelAttrs -
 *	  Workhorse for "*" expansion: produce a list of targetentries
 *	  for the attributes of the RTE
 *
 * As with expandRTE, rtindex/sublevels_up determine the varno/varlevelsup
 * fields of the Vars produced, and location sets their location.
 * pstate->p_next_resno determines the resnos assigned to the TLEs.
 * The referenced columns are marked as requiring SELECT access.
 */
List *
expandRelAttrs(ParseState *pstate, RangeTblEntry *rte,
			   int rtindex, int sublevels_up, int location)
{
	List	   *names,
			   *vars;
	ListCell   *name,
			   *var;
	List	   *te_list = NIL;

	expandRTE(rte, rtindex, sublevels_up, location, false,
			  &names, &vars);

	/*
	 * Require read access to the table.  This is normally redundant with the
	 * markVarForSelectPriv calls below, but not if the table has zero
	 * columns.
	 */
	rte->requiredPerms |= ACL_SELECT;

	forboth(name, names, var, vars)
	{
		char	   *label = strVal(lfirst(name));
		Var		   *varnode = (Var *) lfirst(var);
		TargetEntry *te;

		te = makeTargetEntry((Expr *) varnode,
							 (AttrNumber) pstate->p_next_resno++,
							 label,
							 false);
		te_list = lappend(te_list, te);

		/* Require read access to each column */
		markVarForSelectPriv(pstate, varnode, rte);
	}

	Assert(name == NULL && var == NULL);	/* lists not the same length? */

	return te_list;
}
//其他情况同样进行类似的分析
```

###### ExpandIndirectionStar

###### transformTargetEntry

```c
/*
 * transformTargetEntry()
 *	Transform any ordinary "expression-type" node into a targetlist entry.
 *	This is exported so that parse_clause.c can generate targetlist entries
 *	for ORDER/GROUP BY items that are not already in the targetlist.
 *
 * node		the (untransformed) parse tree for the value expression.
 * expr		the transformed expression, or NULL if caller didn't do it yet.
 * exprKind expression kind (EXPR_KIND_SELECT_TARGET, etc)
 * colname	the column name to be assigned, or NULL if none yet set.
 * resjunk	true if the target should be marked resjunk, ie, it is not
 *			wanted in the final projected tuple.
 */
TargetEntry *
transformTargetEntry(ParseState *pstate,
					 Node *node,
					 Node *expr,
					 ParseExprKind exprKind,
					 char *colname,
					 bool resjunk)
{
	/* Transform the node if caller didn't do it already */
	if (expr == NULL)
	{
		/*
		 * If it's a SetToDefault node and we should allow that, pass it
		 * through unmodified.  (transformExpr will throw the appropriate
		 * error if we're disallowing it.)
		 */
		if (exprKind == EXPR_KIND_UPDATE_SOURCE && IsA(node, SetToDefault))
			expr = node;
		else
			expr = transformExpr(pstate, node, exprKind);
	}

	if (colname == NULL && !resjunk)
	{
		/*
		 * Generate a suitable column name for a column without any explicit
		 * 'AS ColumnName' clause.
		 */
		colname = FigureColname(node);
	}

	return makeTargetEntry((Expr *) expr,
						   (AttrNumber) pstate->p_next_resno++,
						   colname,
						   resjunk);
}
```

```sql
-- 相当于用函数类型来处理
postgres=# select sno(student) from student;
 sno  
------
 1001
 1002
(2 rows)

-- 该查询对应的堆栈结构
Thread #1 [postgres] 3140 [core: 3] (Suspended : Step)	
	transformFuncCall() at parse_expr.c:1,519 0x60c14e	
	transformExprRecurse() at parse_expr.c:265 0x609622	
	transformExpr() at parse_expr.c:155 0x6091f5	
	transformTargetEntry() at parse_target.c:103 0x61e86a	
	transformTargetList() at parse_target.c:191 0x61ea37	
	transformSelectStmt() at analyze.c:1,232 0x5c4dd5	
	transformStmt() at analyze.c:301 0x5c32ef	
	transformOptionalSelectInto() at analyze.c:246 0x5c31ca	
	transformTopLevelStmt() at analyze.c:196 0x5c3088	
	parse_analyze() at analyze.c:116 0x5c2ee0	
	pg_analyze_and_rewrite() at postgres.c:695 0x8e03d1	
	exec_simple_query() at postgres.c:1,140 0x8e0a15	
	PostgresMain() at postgres.c:4,236 0x8e4e0e	
	BackendRun() at postmaster.c:4,431 0x83bb0c	
	BackendStartup() at postmaster.c:4,122 0x83b2ea	
	ServerLoop() at postmaster.c:1,704 0x8376e1	
	PostmasterMain() at postmaster.c:1,377 0x836f97	
	main() at main.c:228 0x758833	
	
postgres=# select student.sno from student;
 sno  
------
 1001
 1002
(2 rows)
-- 该查询对应的堆栈结构	

Thread #1 [postgres] 3140 [core: 1] (Suspended : Step)	
	transformColumnRef() at parse_expr.c:510 0x609e03	
	transformExprRecurse() at parse_expr.c:176 0x6093a8	
	transformExpr() at parse_expr.c:155 0x6091f5	
	transformTargetEntry() at parse_target.c:103 0x61e86a	
	transformTargetList() at parse_target.c:191 0x61ea37	
	transformSelectStmt() at analyze.c:1,232 0x5c4dd5	
	transformStmt() at analyze.c:301 0x5c32ef	
	transformOptionalSelectInto() at analyze.c:246 0x5c31ca	
	transformTopLevelStmt() at analyze.c:196 0x5c3088	
	parse_analyze() at analyze.c:116 0x5c2ee0	
	pg_analyze_and_rewrite() at postgres.c:695 0x8e03d1	
	exec_simple_query() at postgres.c:1,140 0x8e0a15	
	PostgresMain() at postgres.c:4,236 0x8e4e0e	
	BackendRun() at postmaster.c:4,431 0x83bb0c	
	BackendStartup() at postmaster.c:4,122 0x83b2ea	
	ServerLoop() at postmaster.c:1,704 0x8376e1	
	PostmasterMain() at postmaster.c:1,377 0x836f97	
	main() at main.c:228 0x758833	
	
	
-- 上面这两个查询是等价的，但是调用堆栈不同
```

```c
/*
	transformExprRecurse函数根据列的类型采用不同的函数处理
*/
static Node *
transformExprRecurse(ParseState *pstate, Node *expr)
{
	Node	   *result;

	if (expr == NULL)
		return NULL;

	/* Guard against stack overflow due to overly complex expressions */
	check_stack_depth();

	switch (nodeTag(expr))
	{
		case T_ColumnRef:
			result = transformColumnRef(pstate, (ColumnRef *) expr);
			break;

		case T_ParamRef:
			result = transformParamRef(pstate, (ParamRef *) expr);
			break;

		case T_A_Const:
			{
				A_Const    *con = (A_Const *) expr;
				Value	   *val = &con->val;

				result = (Node *) make_const(pstate, val, con->location);
				break;
			}

		case T_A_Indirection:
			result = transformIndirection(pstate, (A_Indirection *) expr);
			break;

		case T_A_ArrayExpr:
			result = transformArrayExpr(pstate, (A_ArrayExpr *) expr,
										InvalidOid, InvalidOid, -1);
			break;

		case T_TypeCast:
			result = transformTypeCast(pstate, (TypeCast *) expr);
			break;

		case T_CollateClause:
			result = transformCollateClause(pstate, (CollateClause *) expr);
			break;

		case T_A_Expr:
			{
				A_Expr	   *a = (A_Expr *) expr;

				switch (a->kind)
				{
					case AEXPR_OP:
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_OP_ANY:
						result = transformAExprOpAny(pstate, a);
						break;
					case AEXPR_OP_ALL:
						result = transformAExprOpAll(pstate, a);
						break;
					case AEXPR_DISTINCT:
					case AEXPR_NOT_DISTINCT:
						result = transformAExprDistinct(pstate, a);
						break;
					case AEXPR_NULLIF:
						result = transformAExprNullIf(pstate, a);
						break;
					case AEXPR_OF:
						result = transformAExprOf(pstate, a);
						break;
					case AEXPR_IN:
						result = transformAExprIn(pstate, a);
						break;
					case AEXPR_LIKE:
					case AEXPR_ILIKE:
					case AEXPR_SIMILAR:
						/* we can transform these just like AEXPR_OP */
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_BETWEEN:
					case AEXPR_NOT_BETWEEN:
					case AEXPR_BETWEEN_SYM:
					case AEXPR_NOT_BETWEEN_SYM:
						result = transformAExprBetween(pstate, a);
						break;
					case AEXPR_PAREN:
						result = transformExprRecurse(pstate, a->lexpr);
						break;
					default:
						elog(ERROR, "unrecognized A_Expr kind: %d", a->kind);
						result = NULL;	/* keep compiler quiet */
						break;
				}
				break;
			}

		case T_BoolExpr:
			result = transformBoolExpr(pstate, (BoolExpr *) expr);
			break;

		case T_FuncCall:
			result = transformFuncCall(pstate, (FuncCall *) expr);
			break;

		case T_MultiAssignRef:
			result = transformMultiAssignRef(pstate, (MultiAssignRef *) expr);
			break;

		case T_GroupingFunc:
			result = transformGroupingFunc(pstate, (GroupingFunc *) expr);
			break;

		case T_NamedArgExpr:
			{
				NamedArgExpr *na = (NamedArgExpr *) expr;

				na->arg = (Expr *) transformExprRecurse(pstate, (Node *) na->arg);
				result = expr;
				break;
			}

		case T_SubLink:
			result = transformSubLink(pstate, (SubLink *) expr);
			break;

		case T_CaseExpr:
			result = transformCaseExpr(pstate, (CaseExpr *) expr);
			break;

		case T_RowExpr:
			result = transformRowExpr(pstate, (RowExpr *) expr, false);
			break;

		case T_CoalesceExpr:
			result = transformCoalesceExpr(pstate, (CoalesceExpr *) expr);
			break;

		case T_MinMaxExpr:
			result = transformMinMaxExpr(pstate, (MinMaxExpr *) expr);
			break;

		case T_SQLValueFunction:
			result = transformSQLValueFunction(pstate,
											   (SQLValueFunction *) expr);
			break;

		case T_XmlExpr:
			result = transformXmlExpr(pstate, (XmlExpr *) expr);
			break;

		case T_XmlSerialize:
			result = transformXmlSerialize(pstate, (XmlSerialize *) expr);
			break;

		case T_NullTest:
			{
				NullTest   *n = (NullTest *) expr;

				if (operator_precedence_warning)
					emit_precedence_warnings(pstate, PREC_GROUP_POSTFIX_IS, "IS",
											 (Node *) n->arg, NULL,
											 n->location);

				n->arg = (Expr *) transformExprRecurse(pstate, (Node *) n->arg);
				/* the argument can be any type, so don't coerce it */
				n->argisrow = type_is_rowtype(exprType((Node *) n->arg));
				result = expr;
				break;
			}

		case T_BooleanTest:
			result = transformBooleanTest(pstate, (BooleanTest *) expr);
			break;

		case T_CurrentOfExpr:
			result = transformCurrentOfExpr(pstate, (CurrentOfExpr *) expr);
			break;

			/*
			 * In all places where DEFAULT is legal, the caller should have
			 * processed it rather than passing it to transformExpr().
			 */
		case T_SetToDefault:
			ereport(ERROR,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("DEFAULT is not allowed in this context"),
					 parser_errposition(pstate,
										((SetToDefault *) expr)->location)));
			break;

			/*
			 * CaseTestExpr doesn't require any processing; it is only
			 * injected into parse trees in a fully-formed state.
			 *
			 * Ordinarily we should not see a Var here, but it is convenient
			 * for transformJoinUsingClause() to create untransformed operator
			 * trees containing already-transformed Vars.  The best
			 * alternative would be to deconstruct and reconstruct column
			 * references, which seems expensively pointless.  So allow it.
			 */
		case T_CaseTestExpr:
		case T_Var:
			{
				result = (Node *) expr;
				break;
			}

		default:
			/* should not reach here */
			elog(ERROR, "unrecognized node type: %d", (int) nodeTag(expr));
			result = NULL;		/* keep compiler quiet */
			break;
	}

	return result;
}
```

##### transformWhereClause(src/backend/parser/parse_clause.c)

```sql
--为了弄清where子句的处理流程，调式如下参数
-- 逻辑操作符是如何处理的(and)
-- 一般的表达式是如何处理的(age=10)
-- 特殊的表达式是如何处理的(in类型的语句)
postgres=# select * from student where age>10 and age in (select age from student);
```

```c
/*
 * transformWhereClause -
 *	  Transform the qualification and make sure it is of type boolean.
 *	  Used for WHERE and allied clauses.
 *
 * constructName does not affect the semantics, but is used in error messages
 */
Node *
transformWhereClause(ParseState *pstate, Node *clause,
					 ParseExprKind exprKind, const char *constructName)
{
	Node	   *qual;

	if (clause == NULL)
		return NULL;
	//使用函数transformExpr来处理,transformtargetlist(处理不含*号)也用到这个函数
    //该函数用来处理各种表达式，这里是用来处理where子句中的表达式
	qual = transformExpr(pstate, clause, exprKind);

	qual = coerce_to_boolean(pstate, qual, constructName);

	return qual;
}
```

###### transformExpr(src/backend/parser/parse_expr.c)

```c
/*
 * transformExpr -
 *	  Analyze and transform expressions. Type checking and type casting is
 *	  done here.  This processing converts the raw grammar output into
 *	  expression trees with fully determined semantics.
 	完成表达式的处理
 */
Node *
transformExpr(ParseState *pstate, Node *expr, ParseExprKind exprKind)
{
	Node	   *result;
	ParseExprKind sv_expr_kind;

	/* Save and restore identity of expression type we're parsing */
	Assert(exprKind != EXPR_KIND_NONE);
	sv_expr_kind = pstate->p_expr_kind;
	pstate->p_expr_kind = exprKind;
	//调用函数transformExprRecurse完成每个操作数的转换处理
	result = transformExprRecurse(pstate, expr);

	pstate->p_expr_kind = sv_expr_kind;

	return result;
}
```

###### transformExprRecurse(src/backend/parser/parse_expr.c)

```c
/*
	expr=T_A_Expr
	调用函数transformExprRecurse完成每个操作数的转换处理
*/
static Node *
transformExprRecurse(ParseState *pstate, Node *expr)
{
	Node	   *result;

	if (expr == NULL)
		return NULL;

	/* Guard against stack overflow due to overly complex expressions */
    //防止堆栈溢出
	check_stack_depth();

    
	switch (nodeTag(expr))
	{
		case T_ColumnRef:
			result = transformColumnRef(pstate, (ColumnRef *) expr);
			break;

		case T_ParamRef:
			result = transformParamRef(pstate, (ParamRef *) expr);
			break;

		case T_A_Const:
			{
				A_Const    *con = (A_Const *) expr;
				Value	   *val = &con->val;

				result = (Node *) make_const(pstate, val, con->location);
				break;
			}

		case T_A_Indirection:
			result = transformIndirection(pstate, (A_Indirection *) expr);
			break;

		case T_A_ArrayExpr:
			result = transformArrayExpr(pstate, (A_ArrayExpr *) expr,
										InvalidOid, InvalidOid, -1);
			break;

		case T_TypeCast:
			result = transformTypeCast(pstate, (TypeCast *) expr);
			break;

		case T_CollateClause:
			result = transformCollateClause(pstate, (CollateClause *) expr);
			break;
		//a-kind=AEXPR_OP
		case T_A_Expr:
			{
				A_Expr	   *a = (A_Expr *) expr;

				switch (a->kind)
				{
                      //如果是一般操作符，由 transformAExprOp函数处理
					case AEXPR_OP:
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_OP_ANY:
						result = transformAExprOpAny(pstate, a);
						break;
					case AEXPR_OP_ALL:
						result = transformAExprOpAll(pstate, a);
						break;
					case AEXPR_DISTINCT:
					case AEXPR_NOT_DISTINCT:
						result = transformAExprDistinct(pstate, a);
						break;
					case AEXPR_NULLIF:
						result = transformAExprNullIf(pstate, a);
						break;
					case AEXPR_OF:
						result = transformAExprOf(pstate, a);
						break;
					case AEXPR_IN:
						result = transformAExprIn(pstate, a);
						break;
					case AEXPR_LIKE:
					case AEXPR_ILIKE:
					case AEXPR_SIMILAR:
						/* we can transform these just like AEXPR_OP */
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_BETWEEN:
					case AEXPR_NOT_BETWEEN:
					case AEXPR_BETWEEN_SYM:
					case AEXPR_NOT_BETWEEN_SYM:
						result = transformAExprBetween(pstate, a);
						break;
					case AEXPR_PAREN:
						result = transformExprRecurse(pstate, a->lexpr);
						break;
					default:
						elog(ERROR, "unrecognized A_Expr kind: %d", a->kind);
						result = NULL;	/* keep compiler quiet */
						break;
				}
				break;
			}
		
         //如果有逻辑操作符，首先进入transformBoolExpr函数处理
		case T_BoolExpr:
			result = transformBoolExpr(pstate, (BoolExpr *) expr);
			break;

		case T_FuncCall:
			result = transformFuncCall(pstate, (FuncCall *) expr);
			break;

		case T_MultiAssignRef:
			result = transformMultiAssignRef(pstate, (MultiAssignRef *) expr);
			break;

		case T_GroupingFunc:
			result = transformGroupingFunc(pstate, (GroupingFunc *) expr);
			break;

		case T_NamedArgExpr:
			{
				NamedArgExpr *na = (NamedArgExpr *) expr;

				na->arg = (Expr *) transformExprRecurse(pstate, (Node *) na->arg);
				result = expr;
				break;
			}

		case T_SubLink:
			result = transformSubLink(pstate, (SubLink *) expr);
			break;

		case T_CaseExpr:
			result = transformCaseExpr(pstate, (CaseExpr *) expr);
			break;

		case T_RowExpr:
			result = transformRowExpr(pstate, (RowExpr *) expr, false);
			break;

		case T_CoalesceExpr:
			result = transformCoalesceExpr(pstate, (CoalesceExpr *) expr);
			break;

		case T_MinMaxExpr:
			result = transformMinMaxExpr(pstate, (MinMaxExpr *) expr);
			break;

		case T_SQLValueFunction:
			result = transformSQLValueFunction(pstate,
											   (SQLValueFunction *) expr);
			break;

		case T_XmlExpr:
			result = transformXmlExpr(pstate, (XmlExpr *) expr);
			break;

		case T_XmlSerialize:
			result = transformXmlSerialize(pstate, (XmlSerialize *) expr);
			break;

		case T_NullTest:
			{
				NullTest   *n = (NullTest *) expr;

				if (operator_precedence_warning)
					emit_precedence_warnings(pstate, PREC_GROUP_POSTFIX_IS, "IS",
											 (Node *) n->arg, NULL,
											 n->location);

				n->arg = (Expr *) transformExprRecurse(pstate, (Node *) n->arg);
				/* the argument can be any type, so don't coerce it */
				n->argisrow = type_is_rowtype(exprType((Node *) n->arg));
				result = expr;
				break;
			}

		case T_BooleanTest:
			result = transformBooleanTest(pstate, (BooleanTest *) expr);
			break;

		case T_CurrentOfExpr:
			result = transformCurrentOfExpr(pstate, (CurrentOfExpr *) expr);
			break;

			/*
			 * In all places where DEFAULT is legal, the caller should have
			 * processed it rather than passing it to transformExpr().
			 */
		case T_SetToDefault:
			ereport(ERROR,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("DEFAULT is not allowed in this context"),
					 parser_errposition(pstate,
										((SetToDefault *) expr)->location)));
			break;

			/*
			 * CaseTestExpr doesn't require any processing; it is only
			 * injected into parse trees in a fully-formed state.
			 *
			 * Ordinarily we should not see a Var here, but it is convenient
			 * for transformJoinUsingClause() to create untransformed operator
			 * trees containing already-transformed Vars.  The best
			 * alternative would be to deconstruct and reconstruct column
			 * references, which seems expensively pointless.  So allow it.
			 */
		case T_CaseTestExpr:
		case T_Var:
			{
				result = (Node *) expr;
				break;
			}

		default:
			/* should not reach here */
			elog(ERROR, "unrecognized node type: %d", (int) nodeTag(expr));
			result = NULL;		/* keep compiler quiet */
			break;
	}

	return result;
}
```

###### transformBoolExpr(src/backend/parser/parse_expr.c)

```c
/*
	如果有逻辑操作符，首先进入transformBoolExpr函数处理
*/
static Node *
transformBoolExpr(ParseState *pstate, BoolExpr *a)
{
	List	   *args = NIL;
	const char *opname;
	ListCell   *lc;
	
    //判断逻辑操作符的类型，这里是AND
	switch (a->boolop)
	{
		case AND_EXPR:
			opname = "AND";
			break;
		case OR_EXPR:
			opname = "OR";
			break;
		case NOT_EXPR:
			opname = "NOT";
			break;
		default:
			elog(ERROR, "unrecognized boolop: %d", (int) a->boolop);
			opname = NULL;		/* keep compiler quiet */
			break;
	}
	//循环处理BoolExpr中每个参数(and左右两边的表达式)
    //length(a->args)=2
	foreach(lc, a->args)
	{
		Node	   *arg = (Node *) lfirst(lc);
		//调用transformExprRecurse函数处理AND的左右两边表达式
		arg = transformExprRecurse(pstate, arg);
		arg = coerce_to_boolean(pstate, arg, opname);
		args = lappend(args, arg);
	}

	return (Node *) makeBoolExpr(a->boolop, args, a->location);
}
```

###### 处理age>10

```c
case T_A_Expr:
		{
			A_Expr	   *a = (A_Expr *) expr;

			switch (a->kind)
				{
                     //如果是一般表达式调用 transformAExprOp函数处理
					case AEXPR_OP:
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_OP_ANY:
						result = transformAExprOpAny(pstate, a);
						break;
					case AEXPR_OP_ALL:
						result = transformAExprOpAll(pstate, a);
						break;
					case AEXPR_DISTINCT:
					case AEXPR_NOT_DISTINCT:
						result = transformAExprDistinct(pstate, a);
						break;
					case AEXPR_NULLIF:
						result = transformAExprNullIf(pstate, a);
						break;
					case AEXPR_OF:
						result = transformAExprOf(pstate, a);
						break;
					case AEXPR_IN:
						result = transformAExprIn(pstate, a);
						break;
					case AEXPR_LIKE:
					case AEXPR_ILIKE:
					case AEXPR_SIMILAR:
						/* we can transform these just like AEXPR_OP */
						result = transformAExprOp(pstate, a);
						break;
					case AEXPR_BETWEEN:
					case AEXPR_NOT_BETWEEN:
					case AEXPR_BETWEEN_SYM:
					case AEXPR_NOT_BETWEEN_SYM:
						result = transformAExprBetween(pstate, a);
						break;
					case AEXPR_PAREN:
						result = transformExprRecurse(pstate, a->lexpr);
						break;
					default:
						elog(ERROR, "unrecognized A_Expr kind: %d", a->kind);
						result = NULL;	/* keep compiler quiet */
						break;
			}
		break;
	}
```

###### transformAExprOp(src/backend/parser/parse_expr.c)

```c
//分别对左右两个操作数按类型进行处理
static Node *
transformAExprOp(ParseState *pstate, A_Expr *a)
{
	Node	   *lexpr = a->lexpr;
	Node	   *rexpr = a->rexpr;
	Node	   *result;

	if (operator_precedence_warning)
	{
		int			opgroup;
		const char *opname;

		opgroup = operator_precedence_group((Node *) a, &opname);
		if (opgroup > 0)
			emit_precedence_warnings(pstate, opgroup, opname,
									 lexpr, rexpr,
									 a->location);

		/* Look through AEXPR_PAREN nodes so they don't affect tests below */
		while (lexpr && IsA(lexpr, A_Expr) &&
			   ((A_Expr *) lexpr)->kind == AEXPR_PAREN)
			lexpr = ((A_Expr *) lexpr)->lexpr;
		while (rexpr && IsA(rexpr, A_Expr) &&
			   ((A_Expr *) rexpr)->kind == AEXPR_PAREN)
			rexpr = ((A_Expr *) rexpr)->lexpr;
	}

	/*
	 * Special-case "foo = NULL" and "NULL = foo" for compatibility with
	 * standards-broken products (like Microsoft's).  Turn these into IS NULL
	 * exprs. (If either side is a CaseTestExpr, then the expression was
	 * generated internally from a CASE-WHEN expression, and
	 * transform_null_equals does not apply.)
	 */
	if (Transform_null_equals &&
		list_length(a->name) == 1 &&
		strcmp(strVal(linitial(a->name)), "=") == 0 &&
		(exprIsNullConstant(lexpr) || exprIsNullConstant(rexpr)) &&
		(!IsA(lexpr, CaseTestExpr) &&!IsA(rexpr, CaseTestExpr)))
	{
		NullTest   *n = makeNode(NullTest);

		n->nulltesttype = IS_NULL;
		n->location = a->location;

		if (exprIsNullConstant(lexpr))
			n->arg = (Expr *) rexpr;
		else
			n->arg = (Expr *) lexpr;

		result = transformExprRecurse(pstate, (Node *) n);
	}
	else if (lexpr && IsA(lexpr, RowExpr) &&
			 rexpr && IsA(rexpr, SubLink) &&
			 ((SubLink *) rexpr)->subLinkType == EXPR_SUBLINK)
	{
		/*
		 * Convert "row op subselect" into a ROWCOMPARE sublink. Formerly the
		 * grammar did this, but now that a row construct is allowed anywhere
		 * in expressions, it's easier to do it here.
		 */
		SubLink    *s = (SubLink *) rexpr;

		s->subLinkType = ROWCOMPARE_SUBLINK;
		s->testexpr = lexpr;
		s->operName = a->name;
		s->location = a->location;
		result = transformExprRecurse(pstate, (Node *) s);
	}
	else if (lexpr && IsA(lexpr, RowExpr) &&
			 rexpr && IsA(rexpr, RowExpr))
	{
		/* ROW() op ROW() is handled specially */
		lexpr = transformExprRecurse(pstate, lexpr);
		rexpr = transformExprRecurse(pstate, rexpr);

		result = make_row_comparison_op(pstate,
										a->name,
										castNode(RowExpr, lexpr)->args,
										castNode(RowExpr, rexpr)->args,
										a->location);
	}
	else
	{
		/* Ordinary scalar operator */
        //普通的标量运算符
		Node	   *last_srf = pstate->p_last_srf;
		/*
			处理左操作数(列名)，再次调用transformExprRecurse函数来处理
			由于左操作数是age(列需要进行对象有效性验证)，所以交给transformColumnRef函数来处理
			nodeTag(expr)=T_ColumnRef
		*/
		lexpr = transformExprRecurse(pstate, lexpr);
        //处理右操作数(常数)，再次调用transformExprRecurse函数来处理
        //nodeTag(expr)=T_A_Const
		rexpr = transformExprRecurse(pstate, rexpr);

		result = (Node *) make_op(pstate,
								  a->name,
								  lexpr,
								  rexpr,
								  last_srf,
								  a->location);
	}

	return result;
}
```

###### 处理age in (select age from student)

```c
//接着处理BoolExpr中的第二个参数
//在PostgreSQL中in类型的子句当做子连接来处理(参考gram.y规则)
case T_SubLink:
			result = transformSubLink(pstate, (SubLink *) expr);
			break;
```

###### transformSubLink(src/backend/parser/parse_expr.c)

```c
//in类型子句作为子连接来处理
static Node *
transformSubLink(ParseState *pstate, SubLink *sublink)
{
	Node	   *result = (Node *) sublink;
	Query	   *qtree;
	const char *err;

	/*
	 * Check to see if the sublink is in an invalid place within the query. We
	 * allow sublinks everywhere in SELECT/INSERT/UPDATE/DELETE, but generally
	 * not in utility statements.
	 */
    //检查子连接所在的位置是否正确
	err = NULL;
	switch (pstate->p_expr_kind)
	{
		case EXPR_KIND_NONE:
			Assert(false);		/* can't happen */
			break;
		case EXPR_KIND_OTHER:
			/* Accept sublink here; caller must throw error if wanted */
			break;
		case EXPR_KIND_JOIN_ON:
		case EXPR_KIND_JOIN_USING:
		case EXPR_KIND_FROM_SUBSELECT:
		case EXPR_KIND_FROM_FUNCTION:
		case EXPR_KIND_WHERE:
		case EXPR_KIND_POLICY:
		case EXPR_KIND_HAVING:
		case EXPR_KIND_FILTER:
		case EXPR_KIND_WINDOW_PARTITION:
		case EXPR_KIND_WINDOW_ORDER:
		case EXPR_KIND_WINDOW_FRAME_RANGE:
		case EXPR_KIND_WINDOW_FRAME_ROWS:
		case EXPR_KIND_WINDOW_FRAME_GROUPS:
		case EXPR_KIND_SELECT_TARGET:
		case EXPR_KIND_INSERT_TARGET:
		case EXPR_KIND_UPDATE_SOURCE:
		case EXPR_KIND_UPDATE_TARGET:
		case EXPR_KIND_GROUP_BY:
		case EXPR_KIND_ORDER_BY:
		case EXPR_KIND_DISTINCT_ON:
		case EXPR_KIND_LIMIT:
		case EXPR_KIND_OFFSET:
		case EXPR_KIND_RETURNING:
		case EXPR_KIND_VALUES:
		case EXPR_KIND_VALUES_SINGLE:
			/* okay */
			break;
		case EXPR_KIND_CHECK_CONSTRAINT:
		case EXPR_KIND_DOMAIN_CHECK:
			err = _("cannot use subquery in check constraint");
			break;
		case EXPR_KIND_COLUMN_DEFAULT:
		case EXPR_KIND_FUNCTION_DEFAULT:
			err = _("cannot use subquery in DEFAULT expression");
			break;
		case EXPR_KIND_INDEX_EXPRESSION:
			err = _("cannot use subquery in index expression");
			break;
		case EXPR_KIND_INDEX_PREDICATE:
			err = _("cannot use subquery in index predicate");
			break;
		case EXPR_KIND_ALTER_COL_TRANSFORM:
			err = _("cannot use subquery in transform expression");
			break;
		case EXPR_KIND_EXECUTE_PARAMETER:
			err = _("cannot use subquery in EXECUTE parameter");
			break;
		case EXPR_KIND_TRIGGER_WHEN:
			err = _("cannot use subquery in trigger WHEN condition");
			break;
		case EXPR_KIND_PARTITION_BOUND:
			err = _("cannot use subquery in partition bound");
			break;
		case EXPR_KIND_PARTITION_EXPRESSION:
			err = _("cannot use subquery in partition key expression");
			break;
		case EXPR_KIND_CALL_ARGUMENT:
			err = _("cannot use subquery in CALL argument");
			break;
		case EXPR_KIND_COPY_WHERE:
			err = _("cannot use subquery in COPY FROM WHERE condition");
			break;
		case EXPR_KIND_GENERATED_COLUMN:
			err = _("cannot use subquery in column generation expression");
			break;

			/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, the behavior will be the same as for EXPR_KIND_OTHER,
			 * which is sane anyway.
			 */
	}
	if (err)
		ereport(ERROR,
				(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
				 errmsg_internal("%s", err),
				 parser_errposition(pstate, sublink->location)));

	pstate->p_hasSubLinks = true;

	/*
	 * OK, let's transform the sub-SELECT.
	 */
    //处理子连接中的子查询
	qtree = parse_sub_analyze(sublink->subselect, pstate, NULL, false, true);

	/*
	 * Check that we got a SELECT.  Anything else should be impossible given
	 * restrictions of the grammar, but check anyway.
	 */
	if (!IsA(qtree, Query) ||
		qtree->commandType != CMD_SELECT)
		elog(ERROR, "unexpected non-SELECT command in SubLink");

	//子查询以query tree的形式加到子连接中
    sublink->subselect = (Node *) qtree;
	//判断子连接的类别(ANY_SUBLINK)
	if (sublink->subLinkType == EXISTS_SUBLINK)
	{
		/*
		 * EXISTS needs no test expression or combining operator. These fields
		 * should be null already, but make sure.
		 */
		sublink->testexpr = NULL;
		sublink->operName = NIL;
	}
	else if (sublink->subLinkType == EXPR_SUBLINK ||
			 sublink->subLinkType == ARRAY_SUBLINK)
	{
		/*
		 * Make sure the subselect delivers a single column (ignoring resjunk
		 * targets).
		 */
		if (count_nonjunk_tlist_entries(qtree->targetList) != 1)
			ereport(ERROR,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("subquery must return only one column"),
					 parser_errposition(pstate, sublink->location)));

		/*
		 * EXPR and ARRAY need no test expression or combining operator. These
		 * fields should be null already, but make sure.
		 */
		sublink->testexpr = NULL;
		sublink->operName = NIL;
	}
	else if (sublink->subLinkType == MULTIEXPR_SUBLINK)
	{
		/* Same as EXPR case, except no restriction on number of columns */
		sublink->testexpr = NULL;
		sublink->operName = NIL;
	}
	else
	{
		/* ALL, ANY, or ROWCOMPARE: generate row-comparing expression */
		Node	   *lefthand;
		List	   *left_list;
		List	   *right_list;
		ListCell   *l;

		if (operator_precedence_warning)
		{
			if (sublink->operName == NIL)
				emit_precedence_warnings(pstate, PREC_GROUP_IN, "IN",
										 sublink->testexpr, NULL,
										 sublink->location);
			else
				emit_precedence_warnings(pstate, PREC_GROUP_POSTFIX_OP,
										 strVal(llast(sublink->operName)),
										 sublink->testexpr, NULL,
										 sublink->location);
		}

		/*
		 * If the source was "x IN (select)", convert to "x = ANY (select)".
		 */ 
        //age in (select age from student)====age = any(select age from student)
		if (sublink->operName == NIL)
			sublink->operName = list_make1(makeString("="));

		/*
		 * Transform lefthand expression, and convert to a list
		 */
        
        //调用函数transformExprRecurse，处理左边表达式(age)
        //由于左操作数是age(列需要进行对象有效性验证)，所以交给transformColumnRef函数来处理
		//nodeTag(expr)=T_ColumnRef
		lefthand = transformExprRecurse(pstate, sublink->testexpr);
		if (lefthand && IsA(lefthand, RowExpr))
			left_list = ((RowExpr *) lefthand)->args;
		else
			left_list = list_make1(lefthand);

		/*
		 * Build a list of PARAM_SUBLINK nodes representing the output columns
		 * of the subquery.
		 */
        //将子连接中的子查询输出列作为right_list
		right_list = NIL;
		foreach(l, qtree->targetList)
		{
			TargetEntry *tent = (TargetEntry *) lfirst(l);
			Param	   *param;

			if (tent->resjunk)
				continue;

			param = makeNode(Param);
			param->paramkind = PARAM_SUBLINK;
			param->paramid = tent->resno;
			param->paramtype = exprType((Node *) tent->expr);
			param->paramtypmod = exprTypmod((Node *) tent->expr);
			param->paramcollid = exprCollation((Node *) tent->expr);
			param->location = -1;

			right_list = lappend(right_list, param);
		}

		/*
		 * We could rely on make_row_comparison_op to complain if the list
		 * lengths differ, but we prefer to generate a more specific error
		 * message.
		 */
		if (list_length(left_list) < list_length(right_list))
			ereport(ERROR,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("subquery has too many columns"),
					 parser_errposition(pstate, sublink->location)));
		if (list_length(left_list) > list_length(right_list))
			ereport(ERROR,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("subquery has too few columns"),
					 parser_errposition(pstate, sublink->location)));

		/*
		 * Identify the combining operator(s) and generate a suitable
		 * row-comparison expression.
		 */
        /*
        	怎样表示age=any(select age from student)这种关系呢？
        	1、首先需要将左操作数(age)转变T_ColumnRef类型，最后转变为list类型
        	   右参数(子连接中的子查询输出列)也转变为list类型
        	   
        	2、通过make_row_comparison_op函数将left_list和right_list封装到RowCompareExpr的lrags和				ragrs
        	3、最后将RowCompareExpr以节点的形式加到sublink->testexpr中
        */
		//sublink->subselect = (Node *) qtree;子查询加到sublink->subselect中去
		sublink->testexpr = make_row_comparison_op(pstate,
												   sublink->operName,
												   left_list,
												   right_list,
												   sublink->location);
	}

	return result;
}
```

左表达式和右表达式以节点的方式作为AndExp节点的左右子树。

##### transformGroupClasuse(src/backend/parser/analyze.c)

```c
/*
	如果groupby子句中的列目前不存在与targetlist中，需要将其加到targetlist中
*/
List *
transformGroupClause(ParseState *pstate, List *grouplist, List **groupingSets,
					 List **targetlist, List *sortClause,
					 ParseExprKind exprKind, bool useSQL99)
{
	List	   *result = NIL;
	List	   *flat_grouplist;
	List	   *gsets = NIL;
	ListCell   *gl;
	bool		hasGroupingSets = false;
	Bitmapset  *seen_local = NULL;

	/*
	 * Recursively flatten implicit RowExprs. (Technically this is only needed
	 * for GROUP BY, per the syntax rules for grouping sets, but we do it
	 * anyway.)
	 */
	flat_grouplist = (List *) flatten_grouping_sets((Node *) grouplist,
													true,
													&hasGroupingSets);

	/*
	 * If the list is now empty, but hasGroupingSets is true, it's because we
	 * elided redundant empty grouping sets. Restore a single empty grouping
	 * set to leave a canonical form: GROUP BY ()
	 */

	if (flat_grouplist == NIL && hasGroupingSets)
	{
		flat_grouplist = list_make1(makeGroupingSet(GROUPING_SET_EMPTY,
													NIL,
													exprLocation((Node *) grouplist)));
	}

  	//循环处理每个grouplist中的列
    /*
    	示例语句:select sno,sname,age from student group by sno,sname,age order by age;
    	grouplist=(sno,sname,age)
    	先处理sno,判断if (IsA(gexpr, GroupingSet))节点的类型
    	如果是GroupingSet类型，由函数transformGroupingSet处理
    	如果不是GroupingSet类型，由函数transformGroupClauseExpr来处理
    */
	foreach(gl, flat_grouplist)
	{
		Node	   *gexpr = (Node *) lfirst(gl);

		if (IsA(gexpr, GroupingSet))
		{
			GroupingSet *gset = (GroupingSet *) gexpr;

			switch (gset->kind)
			{
				case GROUPING_SET_EMPTY:
					gsets = lappend(gsets, gset);
					break;
				case GROUPING_SET_SIMPLE:
					/* can't happen */
					Assert(false);
					break;
				case GROUPING_SET_SETS:
				case GROUPING_SET_CUBE:
				case GROUPING_SET_ROLLUP:
					gsets = lappend(gsets,
									transformGroupingSet(&result,
														 pstate, gset,
														 targetlist, sortClause,
														 exprKind, useSQL99, true));
					break;
			}
		}
		else
		{
			Index		ref = transformGroupClauseExpr(&result, seen_local,
													   pstate, gexpr,
													   targetlist, sortClause,
													   exprKind, useSQL99, true);

			if (ref > 0)
			{
				seen_local = bms_add_member(seen_local, ref);
				if (hasGroupingSets)
					gsets = lappend(gsets,
									makeGroupingSet(GROUPING_SET_SIMPLE,
													list_make1_int(ref),
													exprLocation(gexpr)));
			}
		}
	}

	/* parser should prevent this */
	Assert(gsets == NIL || groupingSets != NULL);

	if (groupingSets)
		*groupingSets = gsets;

	return result;
}
```

###### transformGroupClauseExpr(src/backend/parser/parse_clause.c)

```c
/*
	tle->ressortgroupref:order by子句的引用
*/
static Index
transformGroupClauseExpr(List **flatresult, Bitmapset *seen_local,
						 ParseState *pstate, Node *gexpr,
						 List **targetlist, List *sortClause,
						 ParseExprKind exprKind, bool useSQL99, bool toplevel)
{
	TargetEntry *tle;
	bool		found = false;

	if (useSQL99)
		tle = findTargetlistEntrySQL99(pstate, gexpr,
									   targetlist, exprKind);
	else
		tle = findTargetlistEntrySQL92(pstate, gexpr,
									   targetlist, exprKind);
	//如果group by列存在于order by中
	if (tle->ressortgroupref > 0)
	{
		ListCell   *sl;

		/*
		 * Eliminate duplicates (GROUP BY x, x) but only at local level.
		 * (Duplicates in grouping sets can affect the number of returned
		 * rows, so can't be dropped indiscriminately.)
		 *
		 * Since we don't care about anything except the sortgroupref, we can
		 * use a bitmapset rather than scanning lists.
		 */
		if (bms_is_member(tle->ressortgroupref, seen_local))
			return 0;

		/*
		 * If we're already in the flat clause list, we don't need to consider
		 * adding ourselves again.
		 */
		found = targetIsInSortList(tle, InvalidOid, *flatresult);
		if (found)
			return tle->ressortgroupref;

		/*
		 * If the GROUP BY tlist entry also appears in ORDER BY, copy operator
		 * info from the (first) matching ORDER BY item.  This means that if
		 * you write something like "GROUP BY foo ORDER BY foo USING <<<", the
		 * GROUP BY operation silently takes on the equality semantics implied
		 * by the ORDER BY.  There are two reasons to do this: it improves the
		 * odds that we can implement both GROUP BY and ORDER BY with a single
		 * sort step, and it allows the user to choose the equality semantics
		 * used by GROUP BY, should she be working with a datatype that has
		 * more than one equality operator.
		 *
		 * If we're in a grouping set, though, we force our requested ordering
		 * to be NULLS LAST, because if we have any hope of using a sorted agg
		 * for the job, we're going to be tacking on generated NULL values
		 * after the corresponding groups. If the user demands nulls first,
		 * another sort step is going to be inevitable, but that's the
		 * planner's problem.
		 */
		//存在order by列，就不需要在新创建了，直接复制即可
		foreach(sl, sortClause)
		{
			SortGroupClause *sc = (SortGroupClause *) lfirst(sl);
	
			if (sc->tleSortGroupRef == tle->ressortgroupref)
			{
				SortGroupClause *grpc = copyObject(sc);

				if (!toplevel)
					grpc->nulls_first = false;
				*flatresult = lappend(*flatresult, grpc);
				found = true;
				break;
			}
		}
	}

	/*
	 * If no match in ORDER BY, just add it to the result using default
	 * sort/group semantics.
	 */
    //如果该列不在order by列中，创建一个新的group by语句项(先order by)
	if (!found)
		*flatresult = addTargetToGroupList(pstate, tle,
										   *flatresult, *targetlist,
										   exprLocation(gexpr));

	/*
	 * _something_ must have assigned us a sortgroupref by now...
	 */

	return tle->ressortgroupref;
}
```

## 三、重写模块

### 模块作用

​	根据现有的规则系统，对查询树进行改写，该过程由pg_rewrite_query函数来处理。

### 模块具体实现

#### pg_rewrite_query(src/backend/tcop/postgres.c)

```c
/*
 * Perform rewriting of a query produced by parse analysis.
 *
 * Note: query must just have come from the parser, because we do not do
 * AcquireRewriteLocks() on it.
 */
static List *
pg_rewrite_query(Query *query)
{
	List	   *querytree_list;

	if (Debug_print_parse)
		elog_node_display(LOG, "parse tree", query,
						  Debug_pretty_print);

	if (log_parser_stats)
		ResetUsage();

	if (query->commandType == CMD_UTILITY)
	{
		/* don't rewrite utilities, just dump 'em into result list */
		querytree_list = list_make1(query);
	}
    //实际调用QueryRewrite()函数来重写query树
	else
	{
		/* rewrite regular queries */
		querytree_list = QueryRewrite(query);
	}

	if (log_parser_stats)
		ShowUsage("REWRITER STATISTICS");

#ifdef COPY_PARSE_PLAN_TREES
	/* Optional debugging check: pass querytree through copyObject() */
	{
		List	   *new_list;

		new_list = copyObject(querytree_list);
		/* This checks both copyObject() and the equal() routines... */
		if (!equal(new_list, querytree_list))
			elog(WARNING, "copyObject() failed to produce equal parse tree");
		else
			querytree_list = new_list;
	}
#endif

#ifdef WRITE_READ_PARSE_PLAN_TREES
	/* Optional debugging check: pass querytree through outfuncs/readfuncs */
	{
		List	   *new_list = NIL;
		ListCell   *lc;

		/*
		 * We currently lack outfuncs/readfuncs support for most utility
		 * statement types, so only attempt to write/read non-utility queries.
		 */
		foreach(lc, querytree_list)
		{
			Query	   *query = castNode(Query, lfirst(lc));

			if (query->commandType != CMD_UTILITY)
			{
				char	   *str = nodeToString(query);
				Query	   *new_query = stringToNodeWithLocations(str);

				/*
				 * queryId is not saved in stored rules, but we must preserve
				 * it here to avoid breaking pg_stat_statements.
				 */
				new_query->queryId = query->queryId;

				new_list = lappend(new_list, new_query);
				pfree(str);
			}
			else
				new_list = lappend(new_list, query);
		}

		/* This checks both outfuncs/readfuncs and the equal() routines... */
		if (!equal(new_list, querytree_list))
			elog(WARNING, "outfuncs/readfuncs failed to produce equal parse tree");
		else
			querytree_list = new_list;
	}
#endif

	if (Debug_print_rewritten)
		elog_node_display(LOG, "rewritten parse tree", querytree_list,
						  Debug_pretty_print);

	return querytree_list;
}
```

#### QueryRewrite(src/backend/rewrite/rewriteHandler.c)

```c
/*
 * QueryRewrite -
 *	  Primary entry point to the query rewriter.
 *	  Rewrite one query via query rewrite system, possibly returning 0
 *	  or many queries.
 *
 * NOTE: the parsetree must either have come straight from the parser,
 * or have been scanned by AcquireRewriteLocks to acquire suitable locks.
 */
List *
QueryRewrite(Query *parsetree)
{
	uint64		input_query_id = parsetree->queryId;
	List	   *querylist;
	List	   *results;
	ListCell   *l;
	CmdType		origCmdType;
	bool		foundOriginalQuery;
	Query	   *lastInstead;

	/*
	 * This function is only applied to top-level original queries
	 */
	Assert(parsetree->querySource == QSRC_ORIGINAL);
	Assert(parsetree->canSetTag);

	/*
	 * Step 1
	 *
	 * Apply all non-SELECT rules possibly getting 0 or many queries
	 	执行所有非SELECT规则
	 */
	querylist = RewriteQuery(parsetree, NIL);

	/*
	 * Step 2
	 *
	 * Apply all the RIR rules on each query
	 *
	 * This is also a handy place to mark each query with the original queryId
	 */
	results = NIL;
	foreach(l, querylist)
	{
		Query	   *query = (Query *) lfirst(l);

		query = fireRIRrules(query, NIL);

		query->queryId = input_query_id;

		results = lappend(results, query);
	}

	/*
	 * Step 3
	 *
	 * Determine which, if any, of the resulting queries is supposed to set
	 * the command-result tag; and update the canSetTag fields accordingly.
	 *
	 * If the original query is still in the list, it sets the command tag.
	 * Otherwise, the last INSTEAD query of the same kind as the original is
	 * allowed to set the tag.  (Note these rules can leave us with no query
	 * setting the tag.  The tcop code has to cope with this by setting up a
	 * default tag based on the original un-rewritten query.)
	 *
	 * The Asserts verify that at most one query in the result list is marked
	 * canSetTag.  If we aren't checking asserts, we can fall out of the loop
	 * as soon as we find the original query.
	 */
	origCmdType = parsetree->commandType;
	foundOriginalQuery = false;
	lastInstead = NULL;

	foreach(l, results)
	{
		Query	   *query = (Query *) lfirst(l);

		if (query->querySource == QSRC_ORIGINAL)
		{
			Assert(query->canSetTag);
			Assert(!foundOriginalQuery);
			foundOriginalQuery = true;
#ifndef USE_ASSERT_CHECKING
			break;
#endif
		}
		else
		{
			Assert(!query->canSetTag);
			if (query->commandType == origCmdType &&
				(query->querySource == QSRC_INSTEAD_RULE ||
				 query->querySource == QSRC_QUAL_INSTEAD_RULE))
				lastInstead = query;
		}
	}

	if (!foundOriginalQuery && lastInstead != NULL)
		lastInstead->canSetTag = true;

	return results;
```

##### 第一步

###### RewriteQuery(src/backend/rewrite/rewriteHandler.c)

```c
/*
 * RewriteQuery -
 *	  rewrites the query and apply the rules again on the queries rewritten
 *
 * rewrite_events is a list of open query-rewrite actions, so we can detect
 * infinite recursion.
 */
static List *
RewriteQuery(Query *parsetree, List *rewrite_events)
{
	CmdType		event = parsetree->commandType;
	bool		instead = false;
	bool		returning = false;
	bool		updatableview = false;
	Query	   *qual_product = NULL;
	List	   *rewritten = NIL;
	ListCell   *lc1;

	/*
	 * First, recursively process any insert/update/delete statements in WITH
	 * clauses.  (We have to do this first because the WITH clauses may get
	 * copied into rule actions below.)
	 */
    //首先递归的处理CTE中的DML语句
	foreach(lc1, parsetree->cteList)
	{
		CommonTableExpr *cte = lfirst_node(CommonTableExpr, lc1);
		Query	   *ctequery = castNode(Query, cte->ctequery);
		List	   *newstuff;

		if (ctequery->commandType == CMD_SELECT)
			continue;

		newstuff = RewriteQuery(ctequery, rewrite_events);

		/*
		 * Currently we can only handle unconditional, single-statement DO
		 * INSTEAD rules correctly; we have to get exactly one Query out of
		 * the rewrite operation to stuff back into the CTE node.
		 */
		if (list_length(newstuff) == 1)
		{
			/* Push the single Query back into the CTE node */
			ctequery = linitial_node(Query, newstuff);
			/* WITH queries should never be canSetTag */
			Assert(!ctequery->canSetTag);
			cte->ctequery = (Node *) ctequery;
		}
		else if (newstuff == NIL)
		{
			ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 errmsg("DO INSTEAD NOTHING rules are not supported for data-modifying statements in WITH")));
		}
		else
		{
			ListCell   *lc2;

			/* examine queries to determine which error message to issue */
			foreach(lc2, newstuff)
			{
				Query	   *q = (Query *) lfirst(lc2);

				if (q->querySource == QSRC_QUAL_INSTEAD_RULE)
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("conditional DO INSTEAD rules are not supported for data-modifying statements in WITH")));
				if (q->querySource == QSRC_NON_INSTEAD_RULE)
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("DO ALSO rules are not supported for data-modifying statements in WITH")));
			}

			ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 errmsg("multi-statement DO INSTEAD rules are not supported for data-modifying statements in WITH")));
		}
	}

	/*
	 * If the statement is an insert, update, or delete, adjust its targetlist
	 * as needed, and then fire INSERT/UPDATE/DELETE rules on it.
	 *
	 * SELECT rules are handled later when we have all the queries that should
	 * get executed.  Also, utilities aren't rewritten at all (do we still
	 * need that check?)
	 */
    //如果是DML语句，在必要时调整targetlist
	if (event != CMD_SELECT && event != CMD_UTILITY)
	{
		int			result_relation;
		RangeTblEntry *rt_entry;
		Relation	rt_entry_relation;
		List	   *locks;
		List	   *product_queries;
		bool		hasUpdate = false;
		int			values_rte_index = 0;
		bool		defaults_remaining = false;

		result_relation = parsetree->resultRelation;
		Assert(result_relation != 0);
		rt_entry = rt_fetch(result_relation, parsetree->rtable);
		Assert(rt_entry->rtekind == RTE_RELATION);

		/*
		 * We can use NoLock here since either the parser or
		 * AcquireRewriteLocks should have locked the rel already.
		 */
		rt_entry_relation = table_open(rt_entry->relid, NoLock);

		/*
		 * Rewrite the targetlist as needed for the command type.
		 */
		if (event == CMD_INSERT)
		{
			RangeTblEntry *values_rte = NULL;

			/*
			 * If it's an INSERT ... VALUES (...), (...), ... there will be a
			 * single RTE for the VALUES targetlists.
			 */
			if (list_length(parsetree->jointree->fromlist) == 1)
			{
				RangeTblRef *rtr = (RangeTblRef *) linitial(parsetree->jointree->fromlist);

				if (IsA(rtr, RangeTblRef))
				{
					RangeTblEntry *rte = rt_fetch(rtr->rtindex,
												  parsetree->rtable);

					if (rte->rtekind == RTE_VALUES)
					{
						values_rte = rte;
						values_rte_index = rtr->rtindex;
					}
				}
			}

			if (values_rte)
			{
				/* Process the main targetlist ... */
				parsetree->targetList = rewriteTargetListIU(parsetree->targetList,
															parsetree->commandType,
															parsetree->override,
															rt_entry_relation,
															parsetree->resultRelation);
				/* ... and the VALUES expression lists */
				if (!rewriteValuesRTE(parsetree, values_rte, values_rte_index,
									  rt_entry_relation, false))
					defaults_remaining = true;
			}
			else
			{
				/* Process just the main targetlist */
				parsetree->targetList =
					rewriteTargetListIU(parsetree->targetList,
										parsetree->commandType,
										parsetree->override,
										rt_entry_relation,
										parsetree->resultRelation);
			}

			if (parsetree->onConflict &&
				parsetree->onConflict->action == ONCONFLICT_UPDATE)
			{
				parsetree->onConflict->onConflictSet =
					rewriteTargetListIU(parsetree->onConflict->onConflictSet,
										CMD_UPDATE,
										parsetree->override,
										rt_entry_relation,
										parsetree->resultRelation);
			}
		}
		else if (event == CMD_UPDATE)
		{
			parsetree->targetList =
				rewriteTargetListIU(parsetree->targetList,
									parsetree->commandType,
									parsetree->override,
									rt_entry_relation,
									parsetree->resultRelation);
		}
		else if (event == CMD_DELETE)
		{
			/* Nothing to do here */
		}
		else
			elog(ERROR, "unrecognized commandType: %d", (int) event);

		/*
		 * Collect and apply the appropriate rules.
		 */
		locks = matchLocks(event, rt_entry_relation->rd_rules,
						   result_relation, parsetree, &hasUpdate);

		product_queries = fireRules(parsetree,
									result_relation,
									event,
									locks,
									&instead,
									&returning,
									&qual_product);

		/*
		 * If we have a VALUES RTE with any remaining untouched DEFAULT items,
		 * and we got any product queries, finalize the VALUES RTE for each
		 * product query (replacing the remaining DEFAULT items with NULLs).
		 * We don't do this for the original query, because we know that it
		 * must be an auto-insert on a view, and so should use the base
		 * relation's defaults for any remaining DEFAULT items.
		 */
		if (defaults_remaining && product_queries != NIL)
		{
			ListCell   *n;

			/*
			 * Each product query has its own copy of the VALUES RTE at the
			 * same index in the rangetable, so we must finalize each one.
			 */
			foreach(n, product_queries)
			{
				Query	   *pt = (Query *) lfirst(n);
				RangeTblEntry *values_rte = rt_fetch(values_rte_index,
													 pt->rtable);

				rewriteValuesRTE(pt, values_rte, values_rte_index,
								 rt_entry_relation,
								 true); /* Force remaining defaults to NULL */
			}
		}

		/*
		 * If there were no INSTEAD rules, and the target relation is a view
		 * without any INSTEAD OF triggers, see if the view can be
		 * automatically updated.  If so, we perform the necessary query
		 * transformation here and add the resulting query to the
		 * product_queries list, so that it gets recursively rewritten if
		 * necessary.
		 */
		if (!instead && qual_product == NULL &&
			rt_entry_relation->rd_rel->relkind == RELKIND_VIEW &&
			!view_has_instead_trigger(rt_entry_relation, event))
		{
			/*
			 * This throws an error if the view can't be automatically
			 * updated, but that's OK since the query would fail at runtime
			 * anyway.
			 */
			parsetree = rewriteTargetView(parsetree, rt_entry_relation);

			/*
			 * At this point product_queries contains any DO ALSO rule
			 * actions. Add the rewritten query before or after those.  This
			 * must match the handling the original query would have gotten
			 * below, if we allowed it to be included again.
			 */
			if (parsetree->commandType == CMD_INSERT)
				product_queries = lcons(parsetree, product_queries);
			else
				product_queries = lappend(product_queries, parsetree);

			/*
			 * Set the "instead" flag, as if there had been an unqualified
			 * INSTEAD, to prevent the original query from being included a
			 * second time below.  The transformation will have rewritten any
			 * RETURNING list, so we can also set "returning" to forestall
			 * throwing an error below.
			 */
			instead = true;
			returning = true;
			updatableview = true;
		}

		/*
		 * If we got any product queries, recursively rewrite them --- but
		 * first check for recursion!
		 */
		if (product_queries != NIL)
		{
			ListCell   *n;
			rewrite_event *rev;

			foreach(n, rewrite_events)
			{
				rev = (rewrite_event *) lfirst(n);
				if (rev->relation == RelationGetRelid(rt_entry_relation) &&
					rev->event == event)
					ereport(ERROR,
							(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),
							 errmsg("infinite recursion detected in rules for relation \"%s\"",
									RelationGetRelationName(rt_entry_relation))));
			}

			rev = (rewrite_event *) palloc(sizeof(rewrite_event));
			rev->relation = RelationGetRelid(rt_entry_relation);
			rev->event = event;
			rewrite_events = lcons(rev, rewrite_events);

			foreach(n, product_queries)
			{
				Query	   *pt = (Query *) lfirst(n);
				List	   *newstuff;

				newstuff = RewriteQuery(pt, rewrite_events);
				rewritten = list_concat(rewritten, newstuff);
			}

			rewrite_events = list_delete_first(rewrite_events);
		}

		/*
		 * If there is an INSTEAD, and the original query has a RETURNING, we
		 * have to have found a RETURNING in the rule(s), else fail. (Because
		 * DefineQueryRewrite only allows RETURNING in unconditional INSTEAD
		 * rules, there's no need to worry whether the substituted RETURNING
		 * will actually be executed --- it must be.)
		 */
		if ((instead || qual_product != NULL) &&
			parsetree->returningList &&
			!returning)
		{
			switch (event)
			{
				case CMD_INSERT:
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("cannot perform INSERT RETURNING on relation \"%s\"",
									RelationGetRelationName(rt_entry_relation)),
							 errhint("You need an unconditional ON INSERT DO INSTEAD rule with a RETURNING clause.")));
					break;
				case CMD_UPDATE:
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("cannot perform UPDATE RETURNING on relation \"%s\"",
									RelationGetRelationName(rt_entry_relation)),
							 errhint("You need an unconditional ON UPDATE DO INSTEAD rule with a RETURNING clause.")));
					break;
				case CMD_DELETE:
					ereport(ERROR,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("cannot perform DELETE RETURNING on relation \"%s\"",
									RelationGetRelationName(rt_entry_relation)),
							 errhint("You need an unconditional ON DELETE DO INSTEAD rule with a RETURNING clause.")));
					break;
				default:
					elog(ERROR, "unrecognized commandType: %d",
						 (int) event);
					break;
			}
		}

		/*
		 * Updatable views are supported by ON CONFLICT, so don't prevent that
		 * case from proceeding
		 */
		if (parsetree->onConflict &&
			(product_queries != NIL || hasUpdate) &&
			!updatableview)
			ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 errmsg("INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules")));

		table_close(rt_entry_relation, NoLock);
	}

	/*
	 * For INSERTs, the original query is done first; for UPDATE/DELETE, it is
	 * done last.  This is needed because update and delete rule actions might
	 * not do anything if they are invoked after the update or delete is
	 * performed. The command counter increment between the query executions
	 * makes the deleted (and maybe the updated) tuples disappear so the scans
	 * for them in the rule actions cannot find them.
	 *
	 * If we found any unqualified INSTEAD, the original query is not done at
	 * all, in any form.  Otherwise, we add the modified form if qualified
	 * INSTEADs were found, else the unmodified form.
	 */
	if (!instead)
	{
		if (parsetree->commandType == CMD_INSERT)
		{
			if (qual_product != NULL)
				rewritten = lcons(qual_product, rewritten);
			else
				rewritten = lcons(parsetree, rewritten);
		}
		else
		{
			if (qual_product != NULL)
				rewritten = lappend(rewritten, qual_product);
			else
				rewritten = lappend(rewritten, parsetree);
		}
	}

	/*
	 * If the original query has a CTE list, and we generated more than one
	 * non-utility result query, we have to fail because we'll have copied the
	 * CTE list into each result query.  That would break the expectation of
	 * single evaluation of CTEs.  This could possibly be fixed by
	 * restructuring so that a CTE list can be shared across multiple Query
	 * and PlannableStatement nodes.
	 */
	if (parsetree->cteList != NIL)
	{
		int			qcount = 0;

		foreach(lc1, rewritten)
		{
			Query	   *q = (Query *) lfirst(lc1);

			if (q->commandType != CMD_UTILITY)
				qcount++;
		}
		if (qcount > 1)
			ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 errmsg("WITH cannot be used in a query that is rewritten by rules into multiple queries")));
	}

	return rewritten;
}
```

##### 第二步

```c
/*
	在每个查询上应用规则
*/
results = NIL;
	foreach(l, querylist)
	{
		Query	   *query = (Query *) lfirst(l);

		query = fireRIRrules(query, NIL);

		query->queryId = input_query_id;

		results = lappend(results, query);
	}
```

##### 第三步

```c
//确定哪些查询(如果有的话)应该设置命令-结果标记;并相应地更新canSetTag字段。
origCmdType = parsetree->commandType;
	foundOriginalQuery = false;
	lastInstead = NULL;

	foreach(l, results)
	{
		Query	   *query = (Query *) lfirst(l);

		if (query->querySource == QSRC_ORIGINAL)
		{
			Assert(query->canSetTag);
			Assert(!foundOriginalQuery);
			foundOriginalQuery = true;
#ifndef USE_ASSERT_CHECKING
			break;
#endif
		}
		else
		{
			Assert(!query->canSetTag);
			if (query->commandType == origCmdType &&
				(query->querySource == QSRC_INSTEAD_RULE ||
				 query->querySource == QSRC_QUAL_INSTEAD_RULE))
				lastInstead = query;
		}
	}

	if (!foundOriginalQuery && lastInstead != NULL)
		lastInstead->canSetTag = true;

	return results;
```

