# 		查询分析与重写模块源代码学习

## 一、语法分析和解析模块

### 模块作用

​	用户输入的SQL STATEMENT，经过解析器(Parser),会生成一颗语法树(parser tree)。

### 模块具体实现

​	已经知道SQL语句经过该模块会生成一颗语法树，那么这个流程是怎样实现的呢？

为了能够正确的识别用户输入的SQL语句，PostgreSQL使用词法分析器和语法分析器，按照一定的规则处理来自用户输入的SQL语句。

词法分析器按照词法规则(src/backend/parser/scan.l)，识别SQL语句中单词。

语法分析器按照语法规则(src/backend/parser/gram.y)，对已经转换为单词的SQL语句进行处理，形成SelectStmt节点(语法树的根节点)。

#### SelectStmt数据结构

```c
/*
	src/include/nodes/parsenodes.h
*/
typedef struct SelectStmt
{
	NodeTag		type;

	/*
	 * These fields are used only in "leaf" SelectStmts.
	 */
	List	   *distinctClause; /* NULL, list of DISTINCT ON exprs, or
								 * lcons(NIL,NIL) for all (SELECT DISTINCT) */
	IntoClause *intoClause;		/* target for SELECT INTO */
	List	   *targetList;		/* the target list (of ResTarget) */
	List	   *fromClause;		/* the FROM clause */
	Node	   *whereClause;	/* WHERE qualification */
	List	   *groupClause;	/* GROUP BY clauses */
	Node	   *havingClause;	/* HAVING conditional-expression */
	List	   *windowClause;	/* WINDOW window_name AS (...), ... */

	/*
	 * In a "leaf" node representing a VALUES list, the above fields are all
	 * null, and instead this field is set.  Note that the elements of the
	 * sublists are just expressions, without ResTarget decoration. Also note
	 * that a list element can be DEFAULT (represented as a SetToDefault
	 * node), regardless of the context of the VALUES list. It's up to parse
	 * analysis to reject that where not valid.
	 */
	List	   *valuesLists;	/* untransformed list of expression lists */

	/*
	 * These fields are used in both "leaf" SelectStmts and upper-level
	 * SelectStmts.
	 */
	List	   *sortClause;		/* sort clause (a list of SortBy's) */
	Node	   *limitOffset;	/* # of result tuples to skip */
	Node	   *limitCount;		/* # of result tuples to return */
	List	   *lockingClause;	/* FOR UPDATE (list of LockingClause's) */
	WithClause *withClause;		/* WITH clause */

	/*
	 * These fields are used only in upper-level SelectStmts.
	 */
	SetOperation op;			/* type of set op */
	bool		all;			/* ALL specified? */
	struct SelectStmt *larg;	/* left child */
	struct SelectStmt *rarg;	/* right child */
	/* Eventually add fields for CORRESPONDING spec here */
} SelectStmt;
```

SelectStmt规则定义

```c
/*
	IDENTIFICATION
	src/backend/parser/gram.y
*/
//select语句的类型
SelectStmt: select_no_parens			%prec UMINUS
			| select_with_parens		%prec UMINUS
		;

select_with_parens:
			'(' select_no_parens ')'				{ $$ = $2; }
			| '(' select_with_parens ')'			{ $$ = $2; }
		;

/*
 * This rule parses the equivalent of the standard's <query expression>.
 * The duplicative productions are annoying, but hard to get rid of without
 * creating shift/reduce conflicts.
 *
 *	The locking clause (FOR UPDATE etc) may be before or after LIMIT/OFFSET.
 *	In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
 *	We now support both orderings, but prefer LIMIT/OFFSET before the locking
 * clause.
 *	2002-08-28 bjm
 */
//根据语法规则匹配是简单的select类型，还是带有其他子句的select
//也就是简单select+可选的子句
select_no_parens:
			simple_select						{ $$ = $1; }
			| select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $1, $2, NIL,
										NULL, NULL, NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause for_locking_clause opt_select_limit
				{
					insertSelectOptions((SelectStmt *) $1, $2, $3,
										list_nth($4, 0), list_nth($4, 1),
										NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
					insertSelectOptions((SelectStmt *) $1, $2, $4,
										list_nth($3, 0), list_nth($3, 1),
										NULL,
										yyscanner);
					$$ = $1;
				}
			| with_clause select_clause
				{
					insertSelectOptions((SelectStmt *) $2, NULL, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $2, $3, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit
				{
					insertSelectOptions((SelectStmt *) $2, $3, $4,
										list_nth($5, 0), list_nth($5, 1),
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
					insertSelectOptions((SelectStmt *) $2, $3, $5,
										list_nth($4, 0), list_nth($4, 1),
										$1,
										yyscanner);
					$$ = $2;
				}
		;
		select_clause:
			simple_select							{ $$ = $1; }
			| select_with_parens					{ $$ = $1; }
		;

//simple_select可以包括问题的本质，具体看看简单查询具体的语法规则
//可以看到更据select子句的不同搭配有不同的语法匹配规则，但是都形成了SelectStmt节点
simple_select:
			SELECT opt_all_clause opt_target_list
			into_clause from_clause where_clause
			group_clause having_clause window_clause
				{
				//形成SelectStmt节点
					SelectStmt *n = makeNode(SelectStmt);
/*
					不难发现 opt_target_list子句的匹配规则其实就是形成targetList节点,作为SelectStmt根节点的一个分支节点，类似的其他节点也作为分支节点经过语法解析后加到根节点上。
					target list for SELECT
 *****************************************************************************
opt_target_list: target_list						{ $$ = $1; }
			| /* EMPTY */							{ $$ = NIL; }
			;

target_list:
			target_el								{ $$ = list_make1($1); }
			| target_list ',' target_el				{ $$ = lappend($1, $3); }
		;

target_el:	a_expr AS ColLabel
				{
					$$ = makeNode(ResTarget);
					$$->name = $3;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
					
*/
					n->targetList = $3;
					n->intoClause = $4;
					n->fromClause = $5;
					n->whereClause = $6;
					n->groupClause = $7;
					n->havingClause = $8;
					n->windowClause = $9;
					$$ = (Node *)n;
				}
			| SELECT distinct_clause target_list
			into_clause from_clause where_clause
			group_clause having_clause window_clause
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->distinctClause = $2;
					n->targetList = $3;
					n->intoClause = $4;
					n->fromClause = $5;
					n->whereClause = $6;
					n->groupClause = $7;
					n->havingClause = $8;
					n->windowClause = $9;
					$$ = (Node *)n;
				}
			| values_clause							{ $$ = $1; }
			| TABLE relation_expr
				{
					/* same as SELECT * FROM relation_expr */
					ColumnRef *cr = makeNode(ColumnRef);
					ResTarget *rt = makeNode(ResTarget);
					SelectStmt *n = makeNode(SelectStmt);

					cr->fields = list_make1(makeNode(A_Star));
					cr->location = -1;

					rt->name = NULL;
					rt->indirection = NIL;
					rt->val = (Node *)cr;
					rt->location = -1;

					n->targetList = list_make1(rt);
					n->fromClause = list_make1($2);
					$$ = (Node *)n;
				}
			| select_clause UNION all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_UNION, $3, $1, $4);
				}
			| select_clause INTERSECT all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_INTERSECT, $3, $1, $4);
				}
			| select_clause EXCEPT all_or_distinct select_clause
				{
					$$ = makeSetOp(SETOP_EXCEPT, $3, $1, $4);
				}
		;
```

以上完成了SQL语句到语法树的转换，但是在转换过程中仅仅是对SQL语句进行词法和语法分析(只要SQL符合语法就不会报错)，并没有对SQL语句中语法对象的有效性进行验证并且如果targetlist为‘*’的话，需要转换为基表的列名，而这些工作由分析器来完成。

## 二、查询分析模块

### 模块作用

​	对语法树进行分析(语法对象的有效性验证和*号的转换等工作)

### 模块具体实现

​	输入的parse tree(根节点SelectStmt节点)，输出的query tree(根节点Query)。

#### Query数据结构

```c
/*
	src/include/nodes/parsenodes.h
*/
typedef struct Query
{
	NodeTag		type;

	CmdType		commandType;	/* select|insert|update|delete|utility */

	QuerySource querySource;	/* where did I come from? */

	uint64		queryId;		/* query identifier (can be set by plugins) */

	bool		canSetTag;		/* do I set the command result tag? */

	Node	   *utilityStmt;	/* non-null if commandType == CMD_UTILITY */

	int			resultRelation; /* rtable index of target relation for
								 * INSERT/UPDATE/DELETE; 0 for SELECT */

	bool		hasAggs;		/* has aggregates in tlist or havingQual */
	bool		hasWindowFuncs; /* has window functions in tlist */
	bool		hasTargetSRFs;	/* has set-returning functions in tlist */
	bool		hasSubLinks;	/* has subquery SubLink */
	bool		hasDistinctOn;	/* distinctClause is from DISTINCT ON */
	bool		hasRecursive;	/* WITH RECURSIVE was specified */
	bool		hasModifyingCTE;	/* has INSERT/UPDATE/DELETE in WITH */
	bool		hasForUpdate;	/* FOR [KEY] UPDATE/SHARE was specified */
	bool		hasRowSecurity; /* rewriter has applied some RLS policy */

	List	   *cteList;		/* WITH list (of CommonTableExpr's) */

	List	   *rtable;			/* list of range table entries */
	FromExpr   *jointree;		/* table join tree (FROM and WHERE clauses) */

	List	   *targetList;		/* target list (of TargetEntry) */

	OverridingKind override;	/* OVERRIDING clause */

	OnConflictExpr *onConflict; /* ON CONFLICT DO [NOTHING | UPDATE] */

	List	   *returningList;	/* return-values list (of TargetEntry) */

	List	   *groupClause;	/* a list of SortGroupClause's */

	List	   *groupingSets;	/* a list of GroupingSet's if present */

	Node	   *havingQual;		/* qualifications applied to groups */

	List	   *windowClause;	/* a list of WindowClause's */

	List	   *distinctClause; /* a list of SortGroupClause's */

	List	   *sortClause;		/* a list of SortGroupClause's */

	Node	   *limitOffset;	/* # of result tuples to skip (int8 expr) */
	Node	   *limitCount;		/* # of result tuples to return (int8 expr) */

	List	   *rowMarks;		/* a list of RowMarkClause's */

	Node	   *setOperations;	/* set-operation tree if this is top level of
								 * a UNION/INTERSECT/EXCEPT query */

	List	   *constraintDeps; /* a list of pg_constraint OIDs that the query
								 * depends on to be semantically valid */

	List	   *withCheckOptions;	/* a list of WithCheckOption's (added
									 * during rewrite) */

	/*
	 * The following two fields identify the portion of the source text string
	 * containing this query.  They are typically only populated in top-level
	 * Queries, not in sub-queries.  When not set, they might both be zero, or
	 * both be -1 meaning "unknown".
	 */
	int			stmt_location;	/* start location, or -1 if unknown */
	int			stmt_len;		/* length in bytes; 0 means "rest of string" */
} Query;
```

其实分析模块的作用就是SelectStmt节点到Query节点的转换(每个分支节点也完成转换)，例如targetlist节点在SelectStmt节点中的元素Restarget节点，而在Query节点的元素是TargetEntry节点。

而完成parse tree到query tree转换工作是由pg_analyze_and_rewrite函数实现的，这个函数也完成query tree的重写工作。

#### pg_analyze_and_rewrite

```c
/*
 * Given a raw parsetree (gram.y output), and optionally information about
 * types of parameter symbols ($n), perform parse analysis and rule rewriting.
 *
 * A list of Query nodes is returned, since either the analyzer or the
 * rewriter might expand one query to several.
 *
 * NOTE: for reasons mentioned above, this must be separate from raw parsing.
 */
List *
pg_analyze_and_rewrite(RawStmt *parsetree, const char *query_string,
					   Oid *paramTypes, int numParams,
					   QueryEnvironment *queryEnv)
{
	Query	   *query;
	List	   *querytree_list;

	TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);

	/*
	 * (1) Perform parse analysis.
	 */
	if (log_parser_stats)
		ResetUsage();

	query = parse_analyze(parsetree, query_string, paramTypes, numParams,
						  queryEnv);

	if (log_parser_stats)
		ShowUsage("PARSE ANALYSIS STATISTICS");

	/*
	 * (2) Rewrite the queries, as necessary
	 */
	querytree_list = pg_rewrite_query(query);

	TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);

	return querytree_list;
}
```

pg_analyze_and_rewrite函数分析和重写工作分别由parse_analyze函数和pg_rewrite_query函数来完成。

##### 查看函数堆栈

```bash
(gdb) bt
#0  parse_analyze (parseTree=0x2a92a88, sourceText=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at analyze.c:104
#1  0x00000000008e03d1 in pg_analyze_and_rewrite (parsetree=0x2a92a88, query_string=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:695
#2  0x00000000008e0a15 in exec_simple_query (query_string=0x2a91e98 "select 1;") at postgres.c:1140
#3  0x00000000008e4e0e in PostgresMain (argc=1, argv=0x2abbfa8, dbname=0x2abbe08 "postgres", username=0x2abbde0 "postgres") at postgres.c:4236
#4  0x000000000083bb0c in BackendRun (port=0x2ab3dc0) at postmaster.c:4431
#5  0x000000000083b2ea in BackendStartup (port=0x2ab3dc0) at postmaster.c:4122
#6  0x00000000008376e1 in ServerLoop () at postmaster.c:1704
#7  0x0000000000836f97 in PostmasterMain (argc=3, argv=0x2a8cae0) at postmaster.c:1377
#8  0x0000000000758833 in main (argc=3, argv=0x2a8cae0) at main.c:228
```

##### parse_analyze

```c
/*
	完成分析工作
*/
Query *
parse_analyze(RawStmt *parseTree, const char *sourceText,
			  Oid *paramTypes, int numParams,
			  QueryEnvironment *queryEnv)
{
	ParseState *pstate = make_parsestate(NULL);
	Query	   *query;

	Assert(sourceText != NULL); /* required as of 8.4 */

	pstate->p_sourcetext = sourceText;

	if (numParams > 0)
		parse_fixed_parameters(pstate, paramTypes, numParams);

	pstate->p_queryEnv = queryEnv;
    //调用transformTopLevelStmt函数完成parsetree到query tree的工作
	query = transformTopLevelStmt(pstate, parseTree);

	if (post_parse_analyze_hook)
		(*post_parse_analyze_hook) (pstate, query);

	free_parsestate(pstate);

	return query;
}
```

##### transformTopLevelStmt

```c
Query *
transformTopLevelStmt(ParseState *pstate, RawStmt *parseTree)
{
	Query	   *result;

	/* We're at top level, so allow SELECT INTO */
    //调用了transformOptionalSelectInto函数
	result = transformOptionalSelectInto(pstate, parseTree->stmt);

	result->stmt_location = parseTree->stmt_location;
	result->stmt_len = parseTree->stmt_len;

	return result;
}
```

##### transformOptionalSelectInto

```c
/*
 * transformOptionalSelectInto -
 *	  If SELECT has INTO, convert it to CREATE TABLE AS.
 *
 * The only thing we do here that we don't do in transformStmt() is to
 * convert SELECT ... INTO into CREATE TABLE AS.  Since utility statements
 * aren't allowed within larger statements, this is only allowed at the top
 * of the parse tree, and so we only try it before entering the recursive
 * transformStmt() processing.
 */
/*
	该函数首先判断是不是select into,
		如果是select into将select into(SelectStmt)转换create table as(CreateTableAsStmt)
		如果不是，就交给transformStmt来完成。(其他的Select类型都是由这这个函数来处理的)
*/
static Query *
transformOptionalSelectInto(ParseState *pstate, Node *parseTree)
{
	if (IsA(parseTree, SelectStmt))
	{
		SelectStmt *stmt = (SelectStmt *) parseTree;

		/* If it's a set-operation tree, drill down to leftmost SelectStmt */
		while (stmt && stmt->op != SETOP_NONE)
			stmt = stmt->larg;
		Assert(stmt && IsA(stmt, SelectStmt) &&stmt->larg == NULL);

		if (stmt->intoClause)
		{
			CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);

			ctas->query = parseTree;
			ctas->into = stmt->intoClause;
			ctas->relkind = OBJECT_TABLE;
			ctas->is_select_into = true;

			/*
			 * Remove the intoClause from the SelectStmt.  This makes it safe
			 * for transformSelectStmt to complain if it finds intoClause set
			 * (implying that the INTO appeared in a disallowed place).
			 */
			stmt->intoClause = NULL;

			parseTree = (Node *) ctas;
		}
	}

	return transformStmt(pstate, parseTree);
}
```

#####  transformStmt

```c
 /*
 * transformStmt -
 *	  recursively transform a Parse tree into a Query tree.
 */
Query *
transformStmt(ParseState *pstate, Node *parseTree)
{
	Query	   *result;

	/*
	 * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;
	 * we can't just run it on everything because raw_expression_tree_walker()
	 * doesn't claim to handle utility statements.
	 */
#ifdef RAW_EXPRESSION_COVERAGE_TEST
	switch (nodeTag(parseTree))
	{
		case T_SelectStmt:
		case T_InsertStmt:
		case T_UpdateStmt:
		case T_DeleteStmt:
			(void) test_raw_expression_coverage(parseTree, NULL);
			break;
		default:
			break;
	}
#endif							/* RAW_EXPRESSION_COVERAGE_TEST */

	switch (nodeTag(parseTree))
	{
			/*
			 * Optimizable statements
			 */
		case T_InsertStmt:
			result = transformInsertStmt(pstate, (InsertStmt *) parseTree);
			break;

		case T_DeleteStmt:
			result = transformDeleteStmt(pstate, (DeleteStmt *) parseTree);
			break;

		case T_UpdateStmt:
			result = transformUpdateStmt(pstate, (UpdateStmt *) parseTree);
			break;

   		case T_SelectStmt:
			{
				SelectStmt *n = (SelectStmt *) parseTree;

				if (n->valuesLists)
					result = transformValuesClause(pstate, n);
				else if (n->op == SETOP_NONE)
					result = transformSelectStmt(pstate, n);
				else
					result = transformSetOperationStmt(pstate, n);
			}
			break;

			/*
			 * Special cases
			 */
		case T_DeclareCursorStmt:
			result = transformDeclareCursorStmt(pstate,
												(DeclareCursorStmt *) parseTree);
			break;

		case T_ExplainStmt:
			result = transformExplainStmt(pstate,
										  (ExplainStmt *) parseTree);
			break;

		case T_CreateTableAsStmt:
			result = transformCreateTableAsStmt(pstate,
												(CreateTableAsStmt *) parseTree);
			break;

		case T_CallStmt:
			result = transformCallStmt(pstate,
									   (CallStmt *) parseTree);
			break;

		default:

			/*
			 * other statements don't require any transformation; just return
			 * the original parsetree with a Query node plastered on top.
			 */
			result = makeNode(Query);
			result->commandType = CMD_UTILITY;
			result->utilityStmt = (Node *) parseTree;
			break;
	}

	/* Mark as original query until we learn differently */
	result->querySource = QSRC_ORIGINAL;
	result->canSetTag = true;

	return result;
}
```

接下来通过完整的示例看整个查询执行流程:

### CASE SELECT	

```sql
postgres=# select classno,classname,avg(score) as avg_score from sc,(select * from class where class.gno='grade one') as sub where sc.sno in (select sno from student where student.classno=sub.classno) and sc.cno in (select course.cno from course where course.cname='database') group by classno,classname having avg(score)>60 order by avg_score;
```

#### 调用堆栈

```
#0  transformSelectStmt (pstate=0x2a92b20, stmt=0x2a92970) at analyze.c:1200
#1  0x00000000005c32ef in transformStmt (pstate=0x2a92b20, parseTree=0x2a92970) at analyze.c:301
#2  0x00000000005c31ca in transformOptionalSelectInto (pstate=0x2a92b20, parseTree=0x2a92970) at analyze.c:246
#3  0x00000000005c3088 in transformTopLevelStmt (pstate=0x2a92b20, parseTree=0x2a92a88) at analyze.c:196
#4  0x00000000005c2ee0 in parse_analyze (parseTree=0x2a92a88, sourceText=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at analyze.c:116
#5  0x00000000008e03d1 in pg_analyze_and_rewrite (parsetree=0x2a92a88, query_string=0x2a91e98 "select 1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:695
#6  0x00000000008e0a15 in exec_simple_query (query_string=0x2a91e98 "select 1;") at postgres.c:1140
#7  0x00000000008e4e0e in PostgresMain (argc=1, argv=0x2abbfa8, dbname=0x2abbe08 "postgres", username=0x2abbde0 "postgres") at postgres.c:4236
#8  0x000000000083bb0c in BackendRun (port=0x2ab3dc0) at postmaster.c:4431
#9  0x000000000083b2ea in BackendStartup (port=0x2ab3dc0) at postmaster.c:4122
#10 0x00000000008376e1 in ServerLoop () at postmaster.c:1704
#11 0x0000000000836f97 in PostmasterMain (argc=3, argv=0x2a8cae0) at postmaster.c:1377
#12 0x0000000000758833 in main (argc=3, argv=0x2a8cae0) at main.c:228
```

#### 流程分析

```C
Query *
transformStmt(ParseState *pstate, Node *parseTree)
    /*
    	pstate->p_sourcetext="pasretree对应的原始sql"
    	parseTree->type=T_SelectStmt;
    */
{
	Query	   *result;
    //nodeTag(parseTree)=T_SelectStmt
	switch (nodeTag(parseTree))
	{
		case T_SelectStmt:
			{
				SelectStmt *n = (SelectStmt *) parseTree;
				//判断是不是值表达式，如果是由transformValuesClause来处理
				if (n->valuesLists)
					result = transformValuesClause(pstate, n);
                //如果Select语句中不含集合操作时，由transformSelectStmt来处理，否则由transformSetOperationStmt来处理（这里进入transformSelectStmt函数)
				else if (n->op == SETOP_NONE)
					result = transformSelectStmt(pstate, n);
				else
					result = transformSetOperationStmt(pstate, n);
			}
			break;
	}

	/* 标记为原始查询树 */
	result->querySource = QSRC_ORIGINAL;//该查询树来自parse tree
	result->canSetTag = true;

	return result;
}

//Node结构
typedef struct Node
{
	NodeTag		type;/* 标识节点的类型 */
} Node;

//ParseState结构
struct ParseState
 {
     struct ParseState *parentParseState;    /* stack link */
     const char *p_sourcetext;   /* 原始sql */
     List       *p_rtable;       /* rte列表，将来成为query树范围表 */
     List       *p_joinexprs;    /* JoinExprs for RTE_JOIN p_rtable entries */
     List       *p_joinlist;     /* join items so far (will become FromExpr
                                  * node's fromlist) */
     List       *p_namespace;    /* currently-referenceable RTEs (List of
                                  * ParseNamespaceItem) */
     bool        p_lateral_active;   /* p_lateral_only items visible? */
     List       *p_ctenamespace; /* current namespace for common table exprs */
     List       *p_future_ctes;  /* common table exprs not yet in namespace */
     CommonTableExpr *p_parent_cte;  /* this query's containing CTE */
     Relation    p_target_relation;  /* INSERT/UPDATE/DELETE target rel */
     RangeTblEntry *p_target_rangetblentry;  /* target rel's RTE */
     bool        p_is_insert;    /* process assignment like INSERT not UPDATE */
     List       *p_windowdefs;   /* raw representations of window clauses */
     ParseExprKind p_expr_kind;  /* what kind of expression we're parsing */
     int         p_next_resno;   /* next targetlist resno to assign */
     List       *p_multiassign_exprs;    /* junk tlist entries for multiassign */
     List       *p_locking_clause;   /* raw FOR UPDATE/FOR SHARE info */
     bool        p_locked_from_parent;   /* parent has marked this subquery
                                          * with FOR UPDATE/FOR SHARE */
     bool        p_resolve_unknowns; /* resolve unknown-type SELECT outputs as
                                      * type text */
 
     QueryEnvironment *p_queryEnv;   /* curr env, incl refs to enclosing env */
 
     /* Flags telling about things found in the query: */
     bool        p_hasAggs;
     bool        p_hasWindowFuncs;
     bool        p_hasTargetSRFs;
     bool        p_hasSubLinks;
     bool        p_hasModifyingCTE;
 
     Node       *p_last_srf;     /* most recent set-returning func/op found */
 
     /*
      * Optional hook functions for parser callbacks.  These are null unless
      * set up by the caller of make_parsestate.
      */
     PreParseColumnRefHook p_pre_columnref_hook;
     PostParseColumnRefHook p_post_columnref_hook;
     ParseParamRefHook p_paramref_hook;
     CoerceParamHook p_coerce_param_hook;
     void       *p_ref_hook_state;   /* common passthrough link for above */
 };
```

#### transformSelectStmt

```c
/*
 * transformSelectStmt -
 *	  transforms a Select Statement
 *
 * Note: this covers only cases with no set operations and no VALUES lists;
 * see below for the other cases.
 */
static Query *
transformSelectStmt(ParseState *pstate, SelectStmt *stmt)
{
	Query	   *qry = makeNode(Query);//生成新的Query节点qry
	Node	   *qual;
	ListCell   *l;

	qry->commandType = CMD_SELECT;//设置SQL语句的类型

	/* process the WITH clause independently of all else */
	if (stmt->withClause)
	{
		qry->hasRecursive = stmt->withClause->recursive;
		qry->cteList = transformWithClause(pstate, stmt->withClause);
		qry->hasModifyingCTE = pstate->p_hasModifyingCTE;
	}

	/* Complain if we get called from someplace where INTO is not allowed */
	if (stmt->intoClause)
		ereport(ERROR,
				(errcode(ERRCODE_SYNTAX_ERROR),
				 errmsg("SELECT ... INTO is not allowed here"),
				 parser_errposition(pstate,
									exprLocation((Node *) stmt->intoClause))));

	/* make FOR UPDATE/FOR SHARE info available to addRangeTableEntry */
	pstate->p_locking_clause = stmt->lockingClause;

	/* make WINDOW info available for window functions, too */
	pstate->p_windowdefs = stmt->windowClause;

	/* process the FROM clause */
	transformFromClause(pstate, stmt->fromClause);

	/* transform targetlist */
	qry->targetList = transformTargetList(pstate, stmt->targetList,
										  EXPR_KIND_SELECT_TARGET);

	/* mark column origins */
	markTargetListOrigins(pstate, qry->targetList);

	/* transform WHERE */
	qual = transformWhereClause(pstate, stmt->whereClause,
								EXPR_KIND_WHERE, "WHERE");

	/* initial processing of HAVING clause is much like WHERE clause */
	qry->havingQual = transformWhereClause(pstate, stmt->havingClause,
										   EXPR_KIND_HAVING, "HAVING");

	/*
	 * Transform sorting/grouping stuff.  Do ORDER BY first because both
	 * transformGroupClause and transformDistinctClause need the results. Note
	 * that these functions can also change the targetList, so it's passed to
	 * them by reference.
	 */
	qry->sortClause = transformSortClause(pstate,
										  stmt->sortClause,
										  &qry->targetList,
										  EXPR_KIND_ORDER_BY,
										  false /* allow SQL92 rules */ );

	qry->groupClause = transformGroupClause(pstate,
											stmt->groupClause,
											&qry->groupingSets,
											&qry->targetList,
											qry->sortClause,
											EXPR_KIND_GROUP_BY,
											false /* allow SQL92 rules */ );

	if (stmt->distinctClause == NIL)
	{
		qry->distinctClause = NIL;
		qry->hasDistinctOn = false;
	}
	else if (linitial(stmt->distinctClause) == NULL)
	{
		/* We had SELECT DISTINCT */
		qry->distinctClause = transformDistinctClause(pstate,
													  &qry->targetList,
													  qry->sortClause,
													  false);
		qry->hasDistinctOn = false;
	}
	else
	{
		/* We had SELECT DISTINCT ON */
		qry->distinctClause = transformDistinctOnClause(pstate,
														stmt->distinctClause,
														&qry->targetList,
														qry->sortClause);
		qry->hasDistinctOn = true;
	}

	/* transform LIMIT */
	qry->limitOffset = transformLimitClause(pstate, stmt->limitOffset,
											EXPR_KIND_OFFSET, "OFFSET");
	qry->limitCount = transformLimitClause(pstate, stmt->limitCount,
										   EXPR_KIND_LIMIT, "LIMIT");

	/* transform window clauses after we have seen all window functions */
	qry->windowClause = transformWindowDefinitions(pstate,
												   pstate->p_windowdefs,
												   &qry->targetList);

	/* resolve any still-unresolved output columns as being type text */
	if (pstate->p_resolve_unknowns)
		resolveTargetListUnknowns(pstate, qry->targetList);

	qry->rtable = pstate->p_rtable;
	qry->jointree = makeFromExpr(pstate->p_joinlist, qual);

	qry->hasSubLinks = pstate->p_hasSubLinks;
	qry->hasWindowFuncs = pstate->p_hasWindowFuncs;
	qry->hasTargetSRFs = pstate->p_hasTargetSRFs;
	qry->hasAggs = pstate->p_hasAggs;

	foreach(l, stmt->lockingClause)
	{
		transformLockingClause(pstate, qry,
							   (LockingClause *) lfirst(l), false);
	}

	assign_query_collations(pstate, qry);

	/* this must be done after collations, for reliable comparison of exprs */
	if (pstate->p_hasAggs || qry->groupClause || qry->groupingSets || qry->havingQual)
		parseCheckAggregates(pstate, qry);

	return qry;
}
```

显然，按Select语句中每个子句的类型分类处理。

##### transformFromClause

```c
/*
	处理from子句并向ParseState添加range table,joinlist, and namespace项.
*/
void
transformFromClause(ParseState *pstate, List *frmList)
{
	ListCell   *fl;

	/*
	 * The grammar will have produced a list of RangeVars, RangeSubselects,
	 * RangeFunctions, and/or JoinExprs. Transform each one (possibly adding
	 * entries to the rtable), check for duplicate refnames, and then add it
	 * to the joinlist and namespace.
	 *
	 * Note we must process the items left-to-right for proper handling of
	 * LATERAL references.
	 */
    /*
    	遍历fromlist中的每个元素，交给transformFromClauseItem处理。
    	该函数进行分类处理(基表、子查询、函数)，每个类别的元素都有相应的函数进行处理。
    */
	foreach(fl, frmList)
	{
		Node	   *n = lfirst(fl);
		RangeTblEntry *rte;
		int			rtindex;
		List	   *namespace;

		n = transformFromClauseItem(pstate, n,
									&rte,
									&rtindex,
									&namespace);

		checkNameSpaceConflicts(pstate, pstate->p_namespace, namespace);

		/* Mark the new namespace items as visible only to LATERAL */
		setNamespaceLateralState(namespace, true, true);

        //关系表以RangeTblRef的形式加入到joinlist
        //关系表以RangeTbaleEntry的形式加入到namespace
		pstate->p_joinlist = lappend(pstate->p_joinlist, n);
		pstate->p_namespace = list_concat(pstate->p_namespace, namespace);
	}

	/*
	 * We're done parsing the FROM list, so make all namespace items
	 * unconditionally visible.  Note that this will also reset lateral_only
	 * for any namespace items that were already present when we were called;
	 * but those should have been that way already.
	 */
	setNamespaceLateralState(pstate->p_namespace, false, true);
}
```

###### transformFromClauseItem

```c
// 处理普通关系表(transformTableEntry)
/* 
	将fromlist中的元素(关系表)以RangeTableEntry形式加入到parseState的p_rtable中，后续需要访问
	基表就用p_rtable,
	
	为了能够快速从p_rtable中获得基表的信息，对于每个加入到p_rtable(将来形成query tree的rtable)中的RangeTbaleEntry分配一个唯一索引rtindex，rtindex被封装到RangeTlbRef(形成joinlist)中.
	
	所以RangeTbaleEntry和RangeTlbRef一一对应。
*/
//判断fromlist元素是不是RangeVar类型
if (IsA(n, RangeVar))
	{
		/* Plain relation reference, or perhaps a CTE reference */
		RangeVar   *rv = (RangeVar *) n;
		RangeTblRef *rtr;
		RangeTblEntry *rte;
		int			rtindex;

		/* Check if it's a CTE or tuplestore reference */
    	//判断是否是CTE或者特殊关系类型
		rte = getRTEForSpecialRelationTypes(pstate, rv);
		//如果不是，元素为普通关系表，由transformTableEntry处理
		/* if not found above, must be a table reference */
		if (!rte)
			rte = transformTableEntry(pstate, rv);

		/* assume new rte is at end */
		rtindex = list_length(pstate->p_rtable);
		Assert(rte == rt_fetch(rtindex, pstate->p_rtable));
		*top_rte = rte;
		*top_rti = rtindex;
		*namespace = list_make1(makeDefaultNSItem(rte));
		rtr = makeNode(RangeTblRef);
		rtr->rtindex = rtindex;
		return (Node *) rtr;
	}


// 处理子查询(transformRangeSubselect)
/*
	 子查询也是完整的查询语句，所以先用函数parse_sub_analyze(将子查询先分析成query树)，然后再用
	  addRangeTableEntryForSubquery函数，将子查询(query tree)作为整体以RangTableEntry类型加入到p_rtable中(过程和关系表相同)。
	  
	 有一点区别在于:RTEKind
	 	关系表的RTEkind=RTE_RELATION
	 	子查询的RTEKind=RTE_SUBQUERY
	 	
*/
else if (IsA(n, RangeSubselect))
	{
		/* sub-SELECT is like a plain relation */
		RangeTblRef *rtr;
		RangeTblEntry *rte;
		int			rtindex;

		rte = transformRangeSubselect(pstate, (RangeSubselect *) n);
		/* assume new rte is at end */
		rtindex = list_length(pstate->p_rtable);
		Assert(rte == rt_fetch(rtindex, pstate->p_rtable));
		*top_rte = rte;
		*top_rti = rtindex;
		*namespace = list_make1(makeDefaultNSItem(rte));
		rtr = makeNode(RangeTblRef);
		rtr->rtindex = rtindex;
		return (Node *) rtr;
	}
// 其他类型的from子句同样有相应的函数处理
```

###### transformTableEntry

```c
static RangeTblEntry *
transformTableEntry(ParseState *pstate, RangeVar *r)
{
	RangeTblEntry *rte;

	/* We need only build a range table entry */
	rte = addRangeTableEntry(pstate, r, r->alias, r->inh, true);

	return rte;
}


RangeTblEntry *
addRangeTableEntry(ParseState *pstate,
				   RangeVar *relation,
				   Alias *alias,
				   bool inh,
				   bool inFromCl)
{
	RangeTblEntry *rte = makeNode(RangeTblEntry);
	char	   *refname = alias ? alias->aliasname : relation->relname;
	LOCKMODE	lockmode;
	Relation	rel;

	Assert(pstate != NULL);

	rte->rtekind = RTE_RELATION;
	rte->alias = alias;

	/*
	 * 确定我们在这个关系上需要的锁的类型.  It's not the
	 * query's target table (that case is handled elsewhere), so we need
	 * either RowShareLock if it's locked by FOR UPDATE/SHARE, or plain
	 * AccessShareLock otherwise.
	 */
	lockmode = isLockedRefname(pstate, refname) ? RowShareLock : AccessShareLock;
    
	/*
		获取关系表的OID
	 * Get the rel's OID.  This access also ensures that we have an up-to-date
	 * relcache entry for the rel.  Since this is typically the first access
	 * to a rel in a statement, we must open the rel with the proper lockmode.
	 */
	rel = parserOpenTable(pstate, relation, lockmode);
	rte->relid = RelationGetRelid(rel);
	rte->relkind = rel->rd_rel->relkind;
	rte->rellockmode = lockmode;

	/*
	 * Build the list of effective column names using user-supplied aliases
	 * and/or actual column names.
	 */
	rte->eref = makeAlias(refname, NIL);
	buildRelationAliases(rel->rd_att, alias, rte->eref);

	/*
	 * Drop the rel refcount, but keep the access lock till end of transaction
	 * so that the table can't be deleted or have its schema modified
	 * underneath us.
	 */
	table_close(rel, NoLock);

	/*
	 * Set flags and access permissions.
	 *
	 * The initial default on access checks is always check-for-READ-access,
	 * which is the right thing for all except target tables.
	 */
	rte->lateral = false;
	rte->inh = inh;
	rte->inFromCl = inFromCl;

	rte->requiredPerms = ACL_SELECT;
	rte->checkAsUser = InvalidOid;	/* not set-uid by default, either */
	rte->selectedCols = NULL;
	rte->insertedCols = NULL;
	rte->updatedCols = NULL;
	rte->extraUpdatedCols = NULL;

	/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */
    /*将fromlist中的元素以RangeTableEntry形式加入到parseState的p_rtable中，
    	但是现在不添加到joinlist和namespace中去，在合适的时机做这个操作
    */
	pstate->p_rtable = lappend(pstate->p_rtable, rte);

	return rte;
}
```

###### transformRangeSubselect

```c
/*
  * transformRangeSubselect --- transform a sub-SELECT appearing in FROM
  */
 static RangeTblEntry *
 transformRangeSubselect(ParseState *pstate, RangeSubselect *r)
 {
     Query      *query;
     RangeTblEntry *rte;
 
     /*
      * We require user to supply an alias for a subselect, per SQL92. To relax
      * this, we'd have to be prepared to gin up a unique alias for an
      * unlabeled subselect.  (This is just elog, not ereport, because the
      * grammar should have enforced it already.  It'd probably be better to
      * report the error here, but we don't have a good error location here.)
      */
     //检查子查询是否有别名
     if (r->alias == NULL)
         elog(ERROR, "subquery in FROM must have an alias");
 
     /*
      * Set p_expr_kind to show this parse level is recursing to a subselect.
      * We can't be nested within any expression, so don't need save-restore
      * logic here.
      */
     Assert(pstate->p_expr_kind == EXPR_KIND_NONE);
     pstate->p_expr_kind = EXPR_KIND_FROM_SUBSELECT;
 
     /*
      * If the subselect is LATERAL, make lateral_only names of this level
      * visible to it.  (LATERAL can't nest within a single pstate level, so we
      * don't need save/restore logic here.)
      */
     Assert(!pstate->p_lateral_active);
     pstate->p_lateral_active = r->lateral;
 
     /*
      * Analyze and transform the subquery.
      */
     query = parse_sub_analyze(r->subquery, pstate, NULL,
                               isLockedRefname(pstate, r->alias->aliasname),
                               true);
 
     /* Restore state */
     pstate->p_lateral_active = false;
     pstate->p_expr_kind = EXPR_KIND_NONE;
 
     /*
      * Check that we got a SELECT.  Anything else should be impossible given
      * restrictions of the grammar, but check anyway.
      */
     if (!IsA(query, Query) ||
         query->commandType != CMD_SELECT)
         elog(ERROR, "unexpected non-SELECT command in subquery in FROM");
 
     /*
      * OK, build an RTE for the subquery.
      */
     rte = addRangeTableEntryForSubquery(pstate,
                                         query,
                                         r->alias,
                                         r->lateral,
                                         true);
 
     return rte;
 }
```

到此from子句就已经分析完毕。

#### transformTargetList

```c
/* transform targetlist */
	qry->targetList = transformTargetList(pstate, stmt->targetList,
										  EXPR_KIND_SELECT_TARGET);
/*
  * transformTargetList()
  * Turns a list of ResTarget's into a list of TargetEntry's.
  *
  * This code acts mostly the same for SELECT, UPDATE, or RETURNING lists;
  * the main thing is to transform the given expressions (the "val" fields).
  * The exprKind parameter distinguishes these cases when necessary.
  */

/*
	完成selectstmt中的targetlist(list中的元素以ResTartget类型存在)转换为query中的targetlist(list中的元素以TargetEntry存在)
	
	typedef struct ResTarget
	{
		NodeTag		type;
		char	   *name;			/* column name or NULL */
		List	   *indirection;	/* subscripts, field names, and '*', or NIL */
		Node	   *val;			/* the value expression to compute or assign */
		int			location;		/* token location, or -1 if unknown */
	} ResTarget;

	这个数据结构在select、insert、update都被使用但含义不一样
	select中:
		name:列名的别名
		val:值表达式
		indirection：在select中不可用
	
	insert中:
		name:目标列名
		val:不可用
		indirection:目标列的下标
		
	update中:
		name:目标列名
		val:值表达式
		indirection:目标列的下标
		
*/


/*
	函数ExpandColumnRefStar完成*号的扩展
	函数transformTargetEntry完成restarget到targetentry类型的转换
	
	函数scanRTEForColumn完成目标列的明确性检查，明确该列属于那个基表
*/
 List *
 transformTargetList(ParseState *pstate, List *targetlist,
                     ParseExprKind exprKind)
 {
     List       *p_target = NIL;
     bool        expand_star;
     ListCell   *o_target;
 
     /* Shouldn't have any leftover multiassign items at start */
     Assert(pstate->p_multiassign_exprs == NIL);
 
     /* Expand "something.*" in SELECT and RETURNING, but not UPDATE */
     expand_star = (exprKind != EXPR_KIND_UPDATE_SOURCE);
 
     foreach(o_target, targetlist)
     {
         ResTarget  *res = (ResTarget *) lfirst(o_target);
 
         /*
          * Check for "something.*".  Depending on the complexity of the
          * "something", the star could appear as the last field in ColumnRef,
          * or as the last indirection item in A_Indirection.
          */
         if (expand_star)
         {
             if (IsA(res->val, ColumnRef))
             {
                 ColumnRef  *cref = (ColumnRef *) res->val;
 
                 if (IsA(llast(cref->fields), A_Star))
                 {
                     /* It is something.*, expand into multiple items */
                     p_target = list_concat(p_target,
                                            ExpandColumnRefStar(pstate,
                                                                cref,
                                                                true));
                     continue;
                 }
             }
             else if (IsA(res->val, A_Indirection))
             {
                 A_Indirection *ind = (A_Indirection *) res->val;
 
                 if (IsA(llast(ind->indirection), A_Star))
                 {
                     /* It is something.*, expand into multiple items */
                     p_target = list_concat(p_target,
                                            ExpandIndirectionStar(pstate,
                                                                  ind,
                                                                  true,
                                                                  exprKind));
                     continue;
                 }
             }
         }
 
         /*
          * Not "something.*", or we want to treat that as a plain whole-row
          * variable, so transform as a single expression
          */
         p_target = lappend(p_target,
                            transformTargetEntry(pstate,
                                                 res->val,
                                                 NULL,
                                                 exprKind,
                                                 res->name,
                                                 false));
     }
 
     /*
      * If any multiassign resjunk items were created, attach them to the end
      * of the targetlist.  This should only happen in an UPDATE tlist.  We
      * don't need to worry about numbering of these items; transformUpdateStmt
      * will set their resnos.
      */
     if (pstate->p_multiassign_exprs)
     {
         Assert(exprKind == EXPR_KIND_UPDATE_SOURCE);
         p_target = list_concat(p_target, pstate->p_multiassign_exprs);
         pstate->p_multiassign_exprs = NIL;
     }
 
     return p_target;
 }
```

